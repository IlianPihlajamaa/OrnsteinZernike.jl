var documenterSearchIndex = {"docs":
[{"location":"Accuracy.html#Accuracy","page":"Accuracy","title":"Accuracy","text":"The discrete Fourier tranforms used by the FourierIteration, and NgIteration solvers to represent their continuous counterparts using first order accuracy in n dimensions and second order accuracy in three dimensions (with the trapezoidal rule). To obtain the latter accuracy, it is important that any discontinuities of the interaction potential lie on an exact multiple of dr. To test this, we can compute the pressure of a hard-sphere system, and compare to the exact value. Below, we compute the relative error for different values of the number of gridpoints M, and plot the result on a log-log-scale\n\nusing OrnsteinZernike,  Plots\n\n# Make sure the discontinuity is a multiple of dr\nRmax = 10.0\nM_array = 10 * round.(Int,  10 .^ (range(1,4,length=20)))\np = zeros(length(M_array))\nρ = 0.3\nkBT = 1.0\ndims = 3 \npot = HardSpheres(1.0)\nsystem = SimpleFluid(dims, ρ, kBT, pot)\n\nfor (i,M) in enumerate(M_array)\n    dr = Rmax/M\n    method = NgIteration(M=M, dr=dr, verbose=false)\n    sol = solve(system, PercusYevick(), method)\n    pressure = compute_virial_pressure(sol, system)\n    p[i] = pressure/ρ/kBT-1.0\n    println(\"The pressure = \", round(pressure, digits=8), \" with M = $(M) gridpoints.\")\nend\n\nWe can see that the method has well-behaved second order convergence, and that with M=10^4, we get almost 6 digits of relative accuracy.\n\nη = ρ/6*π\np_exact = (1+2η+3η^2)/(1-η)^2-1.0\nscatter(M_array, abs.(p.-p_exact)./p_exact)\nplot!(ylabel=\"relative error\", xlabel=\"M\", xscale=:log, yscale=:log)\n\nIn principle, these results can be extrapolated to improve the accuracy further.","category":"section"},{"location":"HighDensities.html#Solving-at-high-densities","page":"Solving at high densities","title":"Solving at high densities","text":"Sometimes, especially when dealing with high densities, the solvers do not converge out-of-the-box. It may be necessary to play with the solver settings to get it to converge\n\nusing OrnsteinZernike\nρ = 1.5\nkBT = 1.0\ndims = 3\n\npot = HardSpheres(1.0)\nsystem = SimpleFluid(dims, ρ, kBT, pot)\nclosure = PercusYevick()\nmethod = NgIteration()\nsol = solve(system, closure, method);\n\nAfter iteration 0, the error is 3.41302002652.\nAfter iteration 10, the error is 1.98231818283.\nAfter iteration 20, the error is 1.54425698984.\nAfter iteration 30, the error is 1.31506989937.\n[...]\nAfter iteration 960, the error is 0.12249150013.\nAfter iteration 970, the error is 0.1162956682.\nAfter iteration 980, the error is 0.12306597032.\nAfter iteration 990, the error is 0.10235109774.\nAfter iteration 1000, the error is 0.09999300441.\nERROR: Recursive iteration did not converge within 1001 steps. Current error = 0.09999300441413587.\n\nInstead, we can try to change some solver settings (see NgIteration for detailed descriptions):\n\nusing OrnsteinZernike\nρ = 1.5 # hide\nkBT = 1.0 # hide\ndims = 3 # hide\npot = HardSpheres(1.0) # hide\nsystem = SimpleFluid(dims, ρ, kBT, pot) # hide\nclosure = PercusYevick() # hide\n\nM = 10^4 # number of gridpoints\ndr = 100.0/M # grid spacing\nmax_iterations = 10^4 # max number of iterations before convergence \nN_stages = 8 # number of previous iterations to use for the next guess\n\nmethod = NgIteration(M=M; dr=dr, max_iterations=max_iterations, N_stages=N_stages)\nsol = solve(system, closure, method);\n\nusing Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", lw=4, label=\"iterative\")\nsol2 = solve(system, closure, Exact(M=M; dr=dr));\nplot!(sol2.r, sol2.gr, lw=2, color=:black, label=\"exact\")\n\nWhich converges even though the density is clearly nonphysically high.\n\nSometimes convergence is accelerated if the solution of the same equations at a slightly lower density is used as an initial condition. This is especially useful if the solution is needed at many different densities. While this can be done by hand using the gamma_0 keyword argument of the solve function, a convenient method DensityRamp is implemented to do this automatically. For example, consider a hard sphere system at ρ = 1.2.\n\nusing OrnsteinZernike\nρ = 1.2\nkBT = 1.0\ndims = 3\n\npot = HardSpheres(1.0)\nsystem = SimpleFluid(dims, ρ, kBT, pot)\nclosure = PercusYevick()\nmethod = NgIteration(M=5000, dr=0.01)\nsol = solve(system, closure, method);\n\nAfter iteration 0, the error is 2.51773674949.\nAfter iteration 10, the error is 1.41253963056.\nAfter iteration 20, the error is 1.2605856682.\nAfter iteration 30, the error is 0.70489573233.\nAfter iteration 40, the error is 0.44336537233.\nAfter iteration 50, the error is 0.39947202862.\nAfter iteration 60, the error is 0.25827952962.\nAfter iteration 70, the error is 0.23273727229.\nAfter iteration 80, the error is 0.13551597572.\nAfter iteration 90, the error is 0.13460620172.\nAfter iteration 100, the error is 0.29303789746.\nAfter iteration 110, the error is 0.12428896865.\nAfter iteration 120, the error is 0.13350846977.\nAfter iteration 130, the error is 0.00388920336.\nAfter iteration 140, the error is 0.00018271462.\nAfter iteration 150, the error is 7.94778e-6.\nAfter iteration 160, the error is 1.27727e-6.\nAfter iteration 170, the error is 5.4383e-7.\nAfter iteration 180, the error is 1.78e-9.\nConverged after 185 iterations, the error is 7.0e-11.\n\nTo do this, we can use the DensityRamp solver. This takes two arguments. The first is the actual method by which to solve the equations, which we leave as NgIteration() and the second is a list of densities to be evaluated before the target density. It returns a Vector of solution objects.\n\ndensities = [1.15, 1.18]\nmethod2 = DensityRamp(method, densities)\nsol = @time solve(system, closure, method2);\n\nSolving the system at ρ = 1.15.\n\nAfter iteration 0, the error is 2.45107333815.\nAfter iteration 10, the error is 1.14683100707.\nAfter iteration 20, the error is 0.56643550932.\nAfter iteration 30, the error is 0.49252243775.\nAfter iteration 40, the error is 0.40727608832.\nAfter iteration 50, the error is 0.03465798498.\nAfter iteration 60, the error is 0.00212896547.\nAfter iteration 70, the error is 2.296428e-5.\nAfter iteration 80, the error is 4.4255e-7.\nAfter iteration 90, the error is 1.634e-8.\nConverged after 98 iterations, the error is 3.0e-11.\n\nSolving the system at ρ = 1.18.\n\nAfter iteration 0, the error is 234.73047273369.\nAfter iteration 10, the error is 0.09622279909.\nAfter iteration 20, the error is 0.11509610499.\nAfter iteration 30, the error is 0.03246309423.\nAfter iteration 40, the error is 0.01668981609.\nAfter iteration 50, the error is 0.00030500371.\nAfter iteration 60, the error is 1.38937e-6.\nAfter iteration 70, the error is 1.1985e-7.\nAfter iteration 80, the error is 1.516e-8.\nAfter iteration 90, the error is 9.3e-10.\nAfter iteration 100, the error is 3.0e-10.\nConverged after 104 iterations, the error is 9.0e-11.\n\nSolving the system at ρ = 1.2.\n\nAfter iteration 0, the error is 193.67155095726.\nAfter iteration 10, the error is 0.06503380948.\nAfter iteration 20, the error is 0.11540431925.\nAfter iteration 30, the error is 0.0836301059.\nAfter iteration 40, the error is 0.00063923863.\nAfter iteration 50, the error is 5.98769e-6.\nAfter iteration 60, the error is 4.2188e-7.\nAfter iteration 70, the error is 3.1e-9.\nConverged after 80 iterations, the error is 9.0e-11.\n  0.071976 seconds (17.20 k allocations: 4.204 MiB)\n\nWhile, in total, this has increased the number of iterations done, we have obtained the solution at two different densities as well.","category":"section"},{"location":"Electrolyte_tutorial.html#Electrolyte-Mixtures-with-HNC","page":"Electrolyte Mixtures with HNC","title":"Electrolyte Mixtures with HNC","text":"In this tutorial, we demonstrate how to use OrnsteinZernike.jl to reproduce classical results for symmetric electrolytes obtained with the Hypernetted Chain (HNC) closure. Specifically, this page will reproduce some of the results presented in.\n\nD.‐M. Duh; A. D. J. Haymet, Integral equation theory for charged liquids: Model 2–2 electrolytes and the bridge function, J. Chem. Phys. 97, 7716–7729 (1992).\n\nThis paper studies 2:2 electrolytes (e.g., divalent cations and anions) using integral equation theory. Our goal here is to set up the same model, run the HNC closure, and reproduce the radial distribution functions (RDFs) and excess energies across different concentrations.  \n\n","category":"section"},{"location":"Electrolyte_tutorial.html#Step-1.-Setting-up-the-environment","page":"Electrolyte Mixtures with HNC","title":"Step 1. Setting up the environment","text":"using OrnsteinZernike, StaticArrays\nusing Plots\n\n","category":"section"},{"location":"Electrolyte_tutorial.html#Step-2.-Define-physical-constants","page":"Electrolyte Mixtures with HNC","title":"Step 2. Define physical constants","text":"We work with a set of standard physical constants: particle size σ, dielectric constant ϵr, elementary charge e, vacuum permittivity ϵ0, and Boltzmann constant kB. The parameter B sets the strength of the short-ranged repulsive potential. The values are taken from the paper above.\n\nσ = 2.8428 * 10^-10      # particle size (m)\nϵr = 78.358              # relative permittivity of water at 25 °C\ne = 1.602176634e-19      # elementary charge (C)\nϵ0 = 8.8541878128e-12    # vacuum permittivity (F/m)\nϵ = ϵ0 * ϵr\nkB = 1.380649e-23        # Boltzmann constant (J/K)\nB = 5377.75 * 4 * 10^-10 # repulsion parameter (m K)\nnothing # hide\n\nThe potential used is given by\n\nu_ij(r) = frack_B Bsigma  left(fracsigmarright)^9 +  fracZ_i Z_j e^24piepsilon r\n\nFor convenience, we can also compute the approximate position of the potential minimum (not strictly needed, but useful for diagnostics):\n\nRm = (3^(1/4) * B^(1/8) * kB^(1/8)*(4*π*ϵ)^(1/8)*σ)/(e^(1/4)*2^(1/4))\n\n","category":"section"},{"location":"Electrolyte_tutorial.html#Step-3.-Prepare-plotting","page":"Electrolyte Mixtures with HNC","title":"Step 3. Prepare plotting","text":"We will plot two RDFs: the like–like distribution function g₁₁(r) and the unlike distribution function g₁₂(r).\n\np1 = plot(xlabel=\"r (Å)\", ylab=\"g₁₁(r)\")\np2 = plot(xlabel=\"r (Å)\", ylab=\"g₁₂(r)\")\nnothing # hide\n\n","category":"section"},{"location":"Electrolyte_tutorial.html#Step-4.-Ion-charges-and-thermodynamics","page":"Electrolyte Mixtures with HNC","title":"Step 4. Ion charges and thermodynamics","text":"We consider a symmetric 2:2 electrolyte, so the charges are +2 and –2. The temperature is set to room temperature (298 K). \n\nZ = [2, -2] \nT0 = 273.15\nkBT = kB * (T0 + 25)   # thermal energy at 298 K\n\n\n# Bjerrum length in meters\nbjerrum_length = e^2/(4*π*ϵ*kBT) \nnothing # hide\n\n\n","category":"section"},{"location":"Electrolyte_tutorial.html#Step-5.-Loop-over-concentrations","page":"Electrolyte Mixtures with HNC","title":"Step 5. Loop over concentrations","text":"We now study several salt concentrations (in mol/L). For each concentration:\n\nConvert to number density (per m³).\nBuild the mixture model.\nSolve the Ornstein–Zernike equation with the HNC closure.\nExtract the RDFs and excess energy.\nAdd the results to the plots.\n\nfor (i,c) in enumerate([0.001, 0.02, 0.0625, 0.2, 0.5625]) # mol/L\n    # Convert molar concentration to number density\n    ρ0 = c * 6.02214076e23 * 1e3  \n    ρ = [ρ0, ρ0] # equal density of cations and anions\n\n    # Compute Debye screening parameter\n    κD = sqrt(1/(ϵr * ϵ0 * kBT)* e^2 * sum(ρ .* Z.^2))\n    @show c, Rm * κD\n\n    # Numerical grid settings\n    # From here we work in units of kBT and σ\n    M = 4096\n    dims = 3\n    dr = 0.105 * 10^-10 / σ  \n    Sones = ones(SMatrix{2,2, Float64, 4})\n\n    # Define short-range repulsive potential\n    pot = InversePowerLaw(kB*B/σ*Sones/kBT, Sones, 9)\n\n    # Build system and add Coulomb interactions\n    system = SimpleMixture(dims, ρ*σ^3, 1, pot)\n    system = SimpleChargedMixture(system, Z, bjerrum_length / σ)\n\n    # Choose closure and numerical method\n    closure = HypernettedChain()\n    method = FourierIteration(M = M,\n                              dr = dr,\n                              tolerance = 1e-8,\n                              mixing_parameter = 0.05,\n                              verbose = false,\n                              max_iterations = 10^6)\n\n    # Solve OZ equation with HNC closure\n    sol = solve(system, closure, method,\n                coulombsplitting = OrnsteinZernike.NoCoulombSplitting())\n\n    # Extract RDFs\n    r = sol.r \n    g = sol.gr\n\n    # Compute excess energy (per particle, in reduced units)\n    Ex = OrnsteinZernike.compute_excess_energy(sol, system)\n    @show -Ex\n\n    # Plot g₁₁(r) and g₁₂(r)\n    plot!(p1, r*1e10*σ, g[:, 2, 2], label=\"c=$(c)M\")\n    plot!(p2, r*1e10*σ, g[:, 1, 2], label=\"c=$(c)M\")\nend\n\n","category":"section"},{"location":"Electrolyte_tutorial.html#Step-6.-Display-results","page":"Electrolyte Mixtures with HNC","title":"Step 6. Display results","text":"Finally, we set axis limits and show the combined plots.\n\nplot!(p2, xlims=(0.0, 16.0))\nplot!(p1, xlims=(0.0, 16.0))\n\np = plot(p1, p2, layout=(2,1))\n\n","category":"section"},{"location":"Electrolyte_tutorial.html#Results","page":"Electrolyte Mixtures with HNC","title":"Results","text":"Running this script produces the ion–ion radial distribution functions at different concentrations. These curves reproduce the exact behavior reported in Duh & Haymet (1992). The excess energies match exactly the data from table III (except for one data point for some reason).  ","category":"section"},{"location":"ExtendingClosures.html#Defining-your-own-closure","page":"Defining your own closure","title":"Defining your own closure","text":"Creating a closure amounts to two small steps. First, define a subtype of OrnsteinZernike.Closure. Second, implement how the bridge function should be evaluated through\n\nbridge_function(closure, r, mayer_f, γ) – the standard entry point.\n(Optional) closure_cmulr_point(closure, r, mayer_f, γ_SR, βu, βu_LR_disp, βu_LR_coul, q, uses_renorm) – override this only if you need full control over the numerical formula.\n\nThe default evaluator calls bridge_function, takes care of Coulomb pieces, and handles the dispersion tail when the closure reports that it expects the renormalised quantity (γ^* = γ{SR} - βu{LR}^{disp}). This expectation is communicated via the trait\n\nuses_renormalized_gamma(::Closure) = false\n\nand can be specialised for individual closures whenever needed.\n\nimport OrnsteinZernike: uses_renormalized_gamma\nuses_renormalized_gamma(::MyClosure) = true\n\nDeclaring the trait obliges the user to provide a potential that advertises a dispersion tail. Any subtype of DividedPotential—for example WCADivision or the utility wrapper AllShortRangeDivision—satisfies this requirement. Otherwise the function dispersion_tail must be implemented. If now, the solvers will throw an error before the iteration starts.","category":"section"},{"location":"ExtendingClosures.html#Example","page":"Defining your own closure","title":"Example","text":"Assume that we have forgotten that the HypernettedChain closure is already implemented, and we wanted to reimplement it. The hypernetted chain closure approximates c(r) approx (f(r)+1)exp(gamma(r)) - gamma(r) - 1, or equivalently b(r) approx 0.\n\nFirst we define the type. Note that the new closure must be made a subtype of OrnsteinZernike.Closure\n\nusing OrnsteinZernike\n\nimport OrnsteinZernike.Closure\nstruct MyHNC <: Closure end\n\nThe hypernetted-chain closure is recovered by saying that the bridge function is zero everywhere:\n\nimport OrnsteinZernike.bridge_function\nfunction OrnsteinZernike.bridge_function(::MyHNC, _, _, _)\n    return 0.0\nend\n\nNo explicit trait override is required because the closure does not rely on the renormalised (γ^*).\n\nNow we can use the closure as any other \n\nϵ = 1.0\nσ = 1.0\nn = 12\npotential = InversePowerLaw(ϵ, σ, n)\ndims = 3 \nρ = 0.6 \nkBT = 1.0\nsystem = SimpleFluid(dims, ρ, kBT, potential)\nclosure = MyHNC()\nsol = solve(system, closure)\nusing Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\")\n\nwhich can be compared to that of First steps.","category":"section"},{"location":"ExtendingClosures.html#Mixtures","page":"Defining your own closure","title":"Mixtures","text":"In the case of multicomponent systems the bridge function should return a StaticMatrix of the pair values. Because the arguments are themselves StaticMatrix objects you can rely on broadcasting to write the expressions elementwise.\n\nimport OrnsteinZernike.bridge_function\nfunction OrnsteinZernike.bridge_function(::MyHNC, _, _, γ)\n    return zero(γ) # or any other elementwise expression, e.g. @. ...\nend","category":"section"},{"location":"Theory.html#Theory","page":"Theory","title":"Theory","text":"In this section, we describe our conventions and notation.","category":"section"},{"location":"Theory.html#Single-component-systems","page":"Theory","title":"Single component systems","text":"The Ornstein zernike equation  h(r) = c(r) + rho int dtextbfr c(textbfr)h(textbfr - textbfr)  links the pair correlation function g(r) = h(r)+1 to the number density rho and the direct correlation function c(r). In order to solve it, a second relation between h(r) and c(r) must be specified. This is called the closure relation. \n\nIn practise, the closure relation typically takes the form c(r) = f(gamma(r) r u(r)), where u(r) is the interaciton potential and gamma(r) = h(r) - c(r) is the indirect correlation function. Sometimes, instead the closure is defined for the bridge function b(r), and the closure relation is then given by h(r) - 1 = expleft(-beta u(r) + h(r) - c(r) + b(r) right), where beta = 1k_BT. ","category":"section"},{"location":"Theory.html#Mixtures","page":"Theory","title":"Mixtures","text":"Everything above generalizes to the mixture case:\n\nThe Ornstein zernike equation \n\nh_ij(r) = c_ij(r) + sum_l rho_l int dtextbfr c_il(textbfr)h_lj(textbfr - textbfr)\n\nlinks the pair correlation function g_ij(r) = h_ij(r)+1 to the species specific number density rho_i and the direct correlation function c_ij(r). In order to solve it, a second relation between h_ij(r) and c_ij(r) must be specified. This is called the closure relation. \n\nIn practise, the closure relation typically takes the form c_ij(r) = f(gamma_ij(r) r u_ij(r)), where u_ij(r) is the interaciton potential and gamma_ij(r) = h_ij(r) - c_ij(r) is the indirect correlation function. Sometimes, instead the closure is defined for the bridge function b(r), and the closure relation is then given by h_ij(r) - 1 = expleft(-beta u_ij(r) + h_ij(r) - c_ij(r) + b_ij(r) right), where beta = 1k_BT. ","category":"section"},{"location":"Theory.html#Fourier-Transforms","page":"Theory","title":"Fourier Transforms","text":"The ability to numerically solve the Ornstein-Zernike equation relies heavily on doing repeated Fourier Transforms. In arbitrary dimensions, these Fourier transforms can be written as Hankel transforms in the case that the argument is a radially symmetric function. In particular, in d dimensions, the radial Fourier transform and its inverse are given by\n\nhatF(k) = (2pi)^d2 k ^1-d2int_0^infty dr r^d2J_d2-1(kr)F(r)\n\nF(r) = (2pi)^-d2 r ^1-d2int_0^infty dk k^d2J_d2-1(kr)hatF(k)\n\nin which J_d2-1(x) is the bessel function of order d2-1. In the special cases of 1 and 3 dimensions, the transform simplifies into:\n\nhatF(k) = 2int_0^infty dr cos(kr)F(r)\n\nF(r) = frac1piint_0^infty dk cos(kr)hatF(k)\n\nin 1d, and \n\nhatF(k) = frac4pikint_0^infty dr r sin(kr)F(r)\n\nF(r) = frac12pi^2rint_0^infty dk ksin(kr)hatF(k)\n\nin 3d. This package uses discrete versions of all of the above. ","category":"section"},{"location":"Theory.html#Thermodynamic-properties","page":"Theory","title":"Thermodynamic properties","text":"Using the structure as determined by this package, several thermodynamic properies can be computed. In particular, this package contains methods to compute the (virial) pressure p, the isothermal compressibility chi, and the excess internal energy per particle E_x.\n\nFor mixtures, they are computed respectively from the following definitions\n\np =  k_BT rho_0sum_i x_i - 16 rho_0^2 sum_ij x_i x_j int dtextbfr r g_ij(r) u_ij(r)\n\n1(rho_0 k_BT chi)  = 1 - ρ_0 sum_ij x_i x_j hatc_ij(kto0)\n\n,\n\nE_x =   12 rho_0 sum_ij x_i x_j  int dtextbfr  g_ij(r) u_ij(r)\n\nin which rho_0=NV. The functions to use are compute_virial_pressure, compute_compressibility, and, compute_excess_energy.","category":"section"},{"location":"Theory.html#Thermodynamic-Routes","page":"Theory","title":"Thermodynamic Routes","text":"The Ornstein–Zernike framework gives several thermodynamic quantities:\n\nVirial route (pressure): from (g(r)) and (u'(r)).\nCompressibility route:\ncompute_compressibility returns isothermal compressibility (\\chi).\nPressure via compressibility route requires integration over density using [   \\frac{\\partial (\\beta p)}{\\partial \\rho} \\;=\\; \\frac{1}{S(0)},    \\qquad S(0) = \\rho\\,kBT\\,\\kappaT, ] so [   \\beta p(\\rho) \\;=\\; \\int_0^\\rho \\frac{d\\rho'}{S(0;\\rho')}. ]\nEnergy route: excess internal energy from (g(r)).\n\nBecause closures are approximate, routes generally disagree; the gap is a measure of closure error.\n\n","category":"section"},{"location":"Theory.html#Example:-Virial-Pressure-vs.-Compressibility-Route-Pressure","page":"Theory","title":"Example: Virial Pressure vs. Compressibility-Route Pressure","text":"Below we:\n\ncompute virial pressure directly,  \ncompute (\\chi) at a sequence of densities,  \nintegrate (1/S(0)) to obtain the compressibility-route pressure.\n\nusing OrnsteinZernike\n\n# --- System definition at target temperature and potential ---\nkBT     = 1.0\nσ, ϵ    = 1.0, 1.0\nclosure = Verlet()   # any closure works; V shown here\npotential = InversePowerLaw(ϵ, σ, 8)\n\n# Choose a target density and also a ramp to integrate from 0 → ρ_target\nρ_target   = 0.8\ndelta_ρ = 0.01\nρ_grid     = collect((delta_ρ/2):delta_ρ:(ρ_target-delta_ρ/2))  # avoid 0 to keep numerics stable\nsystem_at = ρ -> SimpleFluid(3, ρ, kBT, potential)\n\n# (1) Virial-route pressure at ρ_target\nsol_target = solve(system_at(ρ_target), closure, NgIteration(M=5000, dr=0.01))\np_virial   = compute_virial_pressure(sol_target, system_at(ρ_target))   # this is \"virial pressure\"\n\n# (2) Compressibility κ_T along a density grid\nchi_values = similar(ρ_grid)\nsols = solve(system_at(ρ_grid[end]), closure, DensityRamp(NgIteration(M=5000, dr=0.01), ρ_grid))\n\nfor (i, ρ) in enumerate(ρ_grid)\n    chi_values[i] = compute_compressibility(sols[i], system_at(ρ))  # Isothermal compressibility κ_T\nend\n\n# (3) Integrate to get compressibility-route pressure:\n#     d(βp)/dρ = 1 / S(0) with S(0) = ρ * kBT * κ_T\nS0 = ρ_grid .* kBT .* chi_values\n\n# Midpoint integration of 1/S0 over ρ to get β p(ρ)\nβp  = delta_ρ * sum(1 ./ S0) \np_comp = kBT * βp    # convert βp → p\n\nprintln(\"Virial-route pressure at          ρ = $(ρ_target): p_virial = $(p_virial)\")\nprintln(\"Compressibility-route pressure at ρ = $(ρ_target): p_comp   = $(p_comp)\")\n\nNotes\n\ncompute_compressibility(sol, system) returns (\\chi) (units of inverse pressure).  \nWe used a density ramp inside the loop to help convergence and reuse previous solutions.  \n\n","category":"section"},{"location":"Theory.html#Why-Routes-Differ","page":"Theory","title":"Why Routes Differ","text":"Virial route is sensitive to short-range structure (contact region).  \nCompressibility route probes long-wavelength fluctuations via (S(0)).  \nDiscrepancies reflect closure approximation error.\n\n","category":"section"},{"location":"Theory.html#Making-Routes-Agree","page":"Theory","title":"Making Routes Agree","text":"Closures like Rogers–Young include a tunable parameter (e.g., (\\alpha)) that can be chosen so that ( p{\\mathrm{vir}} \\approx p{\\mathrm{comp}} ). See the Thermodynamic Consistency tutorial for a bisection example.","category":"section"},{"location":"FromPython.html#Calling-from-Python","page":"From Python","title":"Calling from Python","text":"Using OrnsteinZernike from Python is straighforward","category":"section"},{"location":"FromPython.html#Installing","page":"From Python","title":"Installing","text":"First, install juliacall through the pip package manager, with\n\npip install juliacall\n\nThis package allows one to call julia from python \n\nIn Python (only versions geq 3 are supported), run:\n\nfrom juliacall import Main as jl\n\nwhich will install the latest stable version of Julia the first time it is called. Now install OrnsteinZernike.jl with \n\njl.Pkg.add(\"OrnsteinZernike\")\n\nTo import this package in order to use it we need to run:\n\njl.seval(\"using OrnsteinZernike\")\n\nThe jl.seval function let's us evaluate any julia code from within Python.","category":"section"},{"location":"FromPython.html#Usage","page":"From Python","title":"Usage","text":"We can now use OrnsteinZernike.jl in Python:\n\nfrom juliacall import Main as jl\njl.seval(\"using OrnsteinZernike\")\ndims = 3\nkBT = 1.0\nrho = 0.5\npotential = jl.HardSpheres(1.0)\nsystem = jl.SimpleFluid(dims, rho, kBT, potential)\nclosure = jl.PercusYevick()\nsol = jl.solve(system, closure)\n\nimport matplotlib.pyplot as plt\n\nplt.plot(sol.r, sol.gr)\nplt.xlim(0, 5)\nplt.show()\n\n(Image: image)\n\nSee the documentation of juliacall for more information on how to call Julia from Python.","category":"section"},{"location":"Potentials.html#Interaction-Potentials","page":"Interaction Potentials","title":"Interaction Potentials","text":"This package defines several potentials that can be used out of the box. It is straightforward to implement your own potential, see Defining your own potentials. To evaluate the potential, call OrnsteinZernike.evaluate_potential(potential, r). For example:\n\nusing OrnsteinZernike, Plots\nr = 0.9:0.01:4.0\npotential = LennardJones(1.0, 1.0)\nu = OrnsteinZernike.evaluate_potential(potential, r)\nplot(r, u, xlabel=\"r\", ylabel=\"u(r)\", ylims=(-1,1), label=nothing)","category":"section"},{"location":"Potentials.html#Implemented-interaction-potentials","page":"Interaction Potentials","title":"Implemented interaction potentials","text":"Below is a list of implemented closures. We use the notation shown in the Theory section.","category":"section"},{"location":"Potentials.html#OrnsteinZernike.AllShortRangeDivision","page":"Interaction Potentials","title":"OrnsteinZernike.AllShortRangeDivision","text":"AllShortRangeDivision(potential)\n\nWrapper that marks a potential as already short ranged. The long-range tail is set identically to zero so that closures requesting a renormalised gamma* subtract nothing.\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.CustomPotential","page":"Interaction Potentials","title":"OrnsteinZernike.CustomPotential","text":"CustomPotential\n\nImplements a potential that evaluates a user defined function.\n\nExpects values f, and p, which respecively are a callable and a list of parameters. The function should be called f(r::Number, p) and it should produce either a Number, in the case of a single-component system, or an SMatrix, in the case of a multicomponent system. \n\nExample:\n\nf = (r, p) -> 4*p[1]*((p[2]/r)^12 -  (p[2]/r)^6)\npotential = CustomPotential(f, (1.0, 1.0))\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.GaussianCore","page":"Interaction Potentials","title":"OrnsteinZernike.GaussianCore","text":"GaussianCore\n\nGaussian core (ultrasoft) pair interaction\n\nu(r) = ϵ * exp(-(r/σ)^2)\n\nConstructors:\n\nGaussianCore(ϵ::Number, σ::Number) — single-component\nGaussianCore(ϵ::AbstractVector, σ::AbstractVector) — mixture with  σij = (σi + σj)/2 (additive), ϵij = √(ϵi ϵj) (geometric mean)\nGaussianCore(ϵij::AbstractMatrix, σij::AbstractMatrix) — explicit pair tables\n\nExample:\n\npotential = GaussianCore(1.0, 1.5)\n\nExample (mixture with mixing rules):\n\neps = [1.0, 0.8]\nsig = [1.0, 1.2]\npotential = GaussianCore(eps, sig)\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.HardSpheres","page":"Interaction Potentials","title":"OrnsteinZernike.HardSpheres","text":"HardSpheres\n\nImplements the hard-sphere pair interaction for single component systems $ u(r) = \\infty$ for r  1 and u(r) = 0 for r  1, or u_ij(r) = infty for r  D_ij and u_ij(r) = 0 for r  D_ij for mixtures.\n\nFor mixtures expects either a vector D_i of diameters for each of the species in which case an additive mixing rule is used left(D_ij = (D_i+D_j)2right)  or a matrix D_ij of pair diameters.\n\nExample:\n\npotential = HardSpheres(1.0)\n\nExample:\n\npotential = HardSpheres([0.8, 0.9, 1.0])\n\nDij = rand(3,3)\npotential = HardSpheres(Dij)\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.InversePowerLaw","page":"Interaction Potentials","title":"OrnsteinZernike.InversePowerLaw","text":"InversePowerLaw\n\nImplements the power law pair interaction u(r) = epsilon (sigmar)^n.\n\nExpects values ϵ, σ, and n, which respecively are the strength of the potential and particle size. \n\nExample:\n\npotential = InversePowerLaw(1.0, 2.0, 8)\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.LennardJones","page":"Interaction Potentials","title":"OrnsteinZernike.LennardJones","text":"LennardJones\n\nImplements the Lennard-Jones pair interaction u(r) = 4epsilon (sigmar)^12 - (sigmar)^6.\n\nExpects values ϵ and σ, which respecively are the strength of the potential and particle size. \n\nExample:\n\npotential = LennardJones(1.0, 2.0)\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.Morse","page":"Interaction Potentials","title":"OrnsteinZernike.Morse","text":"Morse\n\nMorse potential:\n\nu(r) = ϵ * (exp(-2α(r-σ)) - 2 exp(-α(r-σ)))\n\nConstructors:\n\nMorse(ϵ::Number, σ::Number, α::Number) — single-component\nMorse(ϵ::AbstractVector, σ::AbstractVector, α::AbstractVector) — mixture with   σij = (σi + σj)/2, ϵij = √(ϵi ϵj), αij = (αi + α_j)/2\nMorse(ϵij::AbstractMatrix, σij::AbstractMatrix, αij::AbstractMatrix) — explicit pair tables\n\nExample:\n\npotential = Morse(1.0, 1.0, 2.0)\n\nExample (mixture with mixing rules):\n\neps = [1.0, 0.8]\nsig = [1.0, 1.2]\nalp = [2.0, 1.5]\npotential = Morse(eps, sig, alp)\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.SquareWell","page":"Interaction Potentials","title":"OrnsteinZernike.SquareWell","text":"SquareWell\n\nSquare-well pair interaction:\n\nu(r) = ∞                     if r < σ\n     = -ϵ                    if σ ≤ r ≤ λσ\n     = 0                     if r > λσ\n\nConstructors:\n\nSquareWell(σ::Number, ϵ::Number, λ::Number) — single-component\nSquareWell(σ::AbstractVector, ϵ::AbstractVector, λ::Number) — mixture with   σij = (σi + σj)/2, ϵij = √(ϵi ϵj)\nSquareWell(σij::AbstractMatrix, ϵij::AbstractMatrix, λ::Number) — explicit pair tables\n\nExample:\n\npotential = SquareWell(1.0, 1.0, 1.5)\n\nExample (mixture with mixing rules):\n\nsig = [0.9, 1.1, 1.0]\neps = [1.0, 0.8, 1.2]\npotential = SquareWell(sig, eps, 1.5)\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.TabulatedPotential","page":"Interaction Potentials","title":"OrnsteinZernike.TabulatedPotential","text":"TabulatedPotential\n\nPiecewise-linear potential defined on a sorted grid r_grid with values u_grid.\n\nLinear interpolation within tabulated range.\nExtrapolation behavior controlled by extrapolation:\n:error (default) — throw if r is outside [rmin, rmax]\n:flat — clamp to end values\n:linear — extend linearly using end slope\n\nExample:\n\nr = range(0.8, 6.0; length=500) |> collect\nu = @. 4.0*((1.0/r)^12 - (1.0/r)^6)  # LJ shape as a table\npot = TabulatedPotential(r, u, :flat)\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.WCADivision","page":"Interaction Potentials","title":"OrnsteinZernike.WCADivision","text":"WCADivision{P<:Potential, T, UC}\n\nfields\n\npotential::Potential \ncutoff : (r_c)\nU_c : U(r=r_c)\n\nSplits the potential at the cutoff point using the WCA splitting rule. This means \n\nu(r) = u_SR(r) + U_LR(r)\n\nwhere U_LR(r) = u(r) for r  r_c, and U(r_c)        for r  r_c, and   USR(r) = 0    for r  r_c, and U(r) - U(r_c) for r  r_c.\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.Yukawa","page":"Interaction Potentials","title":"OrnsteinZernike.Yukawa","text":"Yukawa\n\nScreened-Coulomb / Yukawa pair interaction\n\nu(r) = A * exp(-κ r) / r\n\nConstructors:\n\nYukawa(A::Number, κ::Number) — single-component\nYukawa(q::AbstractVector, κ::Number) — mixture from \"charges\": Aij = qi q_j\nYukawa(Aij::AbstractMatrix, κ::Number) — mixture with explicit pair amplitudes\n\nExample (single component):\n\npotential = Yukawa(1.0, 2.0)  # A=1, κ=2\n\nExample (mixture from charges):\n\nq  = [1.0, -1.0, 2.0]\npot = Yukawa(q, 1.5)\n\nExample (mixture with explicit A_ij):\n\nAij = [1.0 0.2; 0.2 0.5]\npot = Yukawa(Aij, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"GeneralWorkflow.html#General-Workflow","page":"General Workflow","title":"General Workflow","text":"In general, solving an Ornstein-Zernike equation requires the definition of following items. The linked pages describe these in more details. \n\nThe interaction potential: Interaction Potentials\nThe system parameters: density, temperature and dimensionality: Systems \nThe closure relation: Closures\nThe solver: Solvers\n\nOnce these have been defined, solve can be called to solve the system at hand. ","category":"section"},{"location":"Solvers.html#Solvers","page":"Solvers","title":"Solvers","text":"Having defined a SimpleFluid and a Closure, one may choose a method by which to solve the equations. The implemented methods are Exact, FourierIteration, NgIteration. If no method is given the solve function, it will use the default NgIteration.\n\nAll solvers in some way need to define a grid on which to solve the equations. This is done using the keyword arguments for M and dr, which represent respectively the number of grid points, and the spacing between them. Some solvers have additional settings, such as a tolerance. It is important to ensure that dr is small compared to the features of the interaction potential, and that M*dr is sufficiently large. For N dimensional systems, the grid is constructed such that all M points lie below M*dr, but dr may not be the exact grid spacing between all points.\n\nFor the implemented cases, Exact solves the system exactly, or throws an error if the method is not implemented. \n\nThe methods FourierIteration and NgIteration both use recursive iteration to find improved estimates of the solution using Fourier Transforms. NgIteration uses a scheme to accelerate convergence, see Ref. [1].","category":"section"},{"location":"Solvers.html#Solution","page":"Solvers","title":"Solution","text":"The solve function returns an OZSolution object containing both the solution data and convergence information:\n\nr, k: grid points in real and reciprocal space\ngr, Sk, cr, ck, gamma_r, gamma_k: correlation functions\nconverged: whether the solution converged (always true; failures throw exceptions)\niterations: number of iterations performed (0 for Exact)\nfinal_error: final error at termination (0.0 for Exact)\ntermination_reason: :converged or :exact","category":"section"},{"location":"Solvers.html#Meta-solvers","page":"Solvers","title":"Meta-solvers","text":"","category":"section"},{"location":"Solvers.html#References","page":"Solvers","title":"References","text":"[1] Ng, K. C. (1974). Hypernetted chain solutions for the classical one‐component plasma up to Γ= 7000. The Journal of Chemical Physics, 61(7), 2680-2689.","category":"section"},{"location":"Solvers.html#OrnsteinZernike.Exact","page":"Solvers","title":"OrnsteinZernike.Exact","text":"Exact <: Method\n\nSolves the system exactly. This is only implemented for specific systems.\n\nRight now, the implemented exact methods are\n\nthree-dimensional single-component system of hard spheres with the Percus Yevick closure [1]\nthree-dimensional multi-component system of additive hard spheres with the Percus Yevick closure [2]\none-dimensional single-component system of hard spheres with the Percus Yevick closure [3]\nfive-dimensional single-component system of hard spheres with the Percus Yevick closure [3]\n\nConstruct using \n\nExact(;  M=1000, dr = 10.0/M)\n\nHere, M is the number of points that the exact solution is evaluated on, and dr is the grid spacing. These are used to perform Fourier transformations.\n\nExamples\n\nmethod = Exact()\n\nmethod = Exact(M=1000)\n\nmethod = Exact(M=1000, dr=0.01)\n\nReferences:\n\nWertheim, M. S. \"Exact solution of the Percus-Yevick integral equation for hard spheres.\" Physical Review Letters 10.8 (1963): 321.\nBaxter, R. J. \"Ornstein–Zernike relation and Percus–Yevick approximation for fluid mixtures.\" The Journal of Chemical Physics 52.9 (1970): 4559-4562.\nLeutheusser, E. \"Exact solution of the Percus-Yevick equation for a hard-core fluid in odd dimensions.\" Physica A: Statistical Mechanics and its Applications 127.3 (1984): 667-676.\n\n\n\n\n\n","category":"type"},{"location":"Solvers.html#OrnsteinZernike.FourierIteration","page":"Solvers","title":"OrnsteinZernike.FourierIteration","text":"FourierIteration <: Method\n\nSolves the system by recursive iteration in Fourier Space. Essentially, the algorithm is:\n\nguess an initial γ(r)\nfind c(r) using the closure relation\nfourier transform to get ĉ(k)\nfind γ(k) using the OZ-eq in k-space\ncompute γ(r) with a inverse fourier transform\ncompare with previous value, if not converged go to 2.\n\nOptionally, a mixing rule is used to mix the new and previous iteration of c(r) in step 2. \n\nArguments:\n\nM::Int: number of points discretize the solution on \ndr::Float64: grid spacing in real space\nmixing_parameter::Float64: mixing parameter for iteration mixing. A value of 1 is no mixing. Must be between 0 and 1. \nmax_iterations::Int64: maximal number of iterations \ntolerance::Float64: tolerance to be reached\nverbose::Bool: whether or not to print convergence information\n\nDefault: FourierIteration(; mixing_parameter=0.5, max_iterations=10^5, tolerance=10^-6, verbose=true, M=1000, dr=10.0/M)\n\n\n\n\n\n","category":"type"},{"location":"Solvers.html#OrnsteinZernike.NgIteration","page":"Solvers","title":"OrnsteinZernike.NgIteration","text":"NgIteration <: Method\n\nSolves the system by recursive iteration in Fourier Space, and uses the Ng acceleration method. Essentially, the algorithm is:\n\nguess an initial γ(r)\nfind c(r) using the closure relation\nfourier transform to get ĉ(k)\nfind γ(k) using the OZ-eq in k-space\ncompute γ(r) with a inverse fourier transform\nuse Ng's method to provide a next guess for γ\ncompare with previous value, if not converged go to 2.\n\nArguments:\n\nM::Int: number of points discretize the solution on \ndr::Float64: grid spacing in real space\nN_stages::Int: Number of previous values to take into account for step 6. A higher number should lead to faster convergence, yet more computation time per iteration.\nmax_iterations::Int64: maximal number of iterations \ntolerance::Float64: tolerance to be reached\nverbose::Bool: whether or not to print convergence information\n\nDefault: NgIteration(; N_stages=3, max_iterations=10^3, tolerance=10^-6, verbose=true, M=1000, dr=10.0/M)\n\nReferences: Ng, K. C. (1974). Hypernetted chain solutions for the classical one‐component plasma up to Γ= 7000. The Journal of Chemical Physics, 61(7), 2680-2689.\n\n\n\n\n\n","category":"type"},{"location":"Solvers.html#OrnsteinZernike.DensityRamp","page":"Solvers","title":"OrnsteinZernike.DensityRamp","text":"DensityRamp <: Method\n\nSolves the system by iteratively solving systems of increasing density, using the previous solution as initial guess at a higher density. This may help deal with convergence issues.\n\nArguments\n\nmethod: method by which to solve the system for individual densities.\ndensities: densities to consider. Must be a vector of increasing values.\nverbose: whether to print information.\n\nExample: DensityRamp(NgIteration(), [0.1, 0.3, 0.4]; verbose=false)\n\n\n\n\n\n","category":"type"},{"location":"Solvers.html#OrnsteinZernike.TemperatureRamp","page":"Solvers","title":"OrnsteinZernike.TemperatureRamp","text":"TemperatureRamp <: Method\n\nSolves the system by iteratively solving systems of decreasing Temperature, using the previous solution as initial guess at a lower temperature. This may help deal with convergence issues.\n\nArguments\n\nmethod: method by which to solve the system for individual temperatures.\ntemperatures: temperatures to consider. Must be a vector of increasing values.\nverbose: whether to print information.\n\nExample: TemperatureRamp(NgIteration(), [0.1, 0.3, 0.4]; verbose=false)\n\n\n\n\n\n","category":"type"},{"location":"Grid.html#Choosing-Grid-Parameters-(M-and-dr)","page":"Choosing Grid Parameters (M and dr)","title":"Choosing Grid Parameters (M and dr)","text":"The Ornstein–Zernike solvers use radial Fourier/Hankel transforms to go between real and Fourier space.   The grid is controlled by two parameters:\n\nM : number of grid points  \ndr: approximate radial step size (may not be truly uniform, since Hankel transforms use non-uniform grids in arbitrary dimensions)  \n\nThe maximum radius is\n\n[ r_{\\max} = M \\cdot dr ]\n\nwhich sets the size of the box in real space.\n\n","category":"section"},{"location":"Grid.html#What-Must-Be-Resolved?","page":"Choosing Grid Parameters (M and dr)","title":"What Must Be Resolved?","text":"In real space, it is the direct correlation function (c(r)) that is Fourier transformed.  \nTherefore, dr and rmax must be chosen such that oscillations and decay of (c(r)) are well resolved.  \nPoor resolution of (c(r)) will produce inaccurate structure factors (S(k)).\nIn a three-dimensional system, if the potential has discontinuities, they must lie exactly between two gridpoints to ensure second order convergence.\nIn Fourier space, the discretization also needs to be accurate.  \nIf the (k)-grid is too coarse, long-wavelength properties (e.g. (S(k\\to 0))) will be unreliable. Ensure that the direct correlation function (\\gamma(k)) is well discretized.\nIf (r_{\\max}) is too small, aliasing and finite-box effects may distort the Fourier transform.\n\n","category":"section"},{"location":"Grid.html#Practical-Guidelines","page":"Choosing Grid Parameters (M and dr)","title":"Practical Guidelines","text":"Choose dr small enough to resolve short-range features of the potential and resulting (c(r)).  \nFor hard spheres or Lennard–Jones: dr ≲ 0.05σ.  \nChoose rmax large enough so that (c(r)) has decayed essentially to zero before the cutoff.  \nA good starting point: rmax ≈ 10σ.  \nIncrease M together with decreasing dr if necessary — this improves both real-space and Fourier-space resolution.  \nCheck convergence: repeat a calculation with finer grid and verify (g(r)), (S(k)), and thermodynamic routes are stable.\n\n","category":"section"},{"location":"Grid.html#Example:-Grid-Convergence-with-dr","page":"Choosing Grid Parameters (M and dr)","title":"Example: Grid Convergence with dr","text":"using OrnsteinZernike, Plots\n\nsystem = SimpleFluid(3, 0.8, 1.0, LennardJones(1.0, 1.0))\nclosure = HypernettedChain()\n\nRmax = 10.0\np1 = plot(xlims=(0,2), xlabel=\"r\", ylabel=\"c(r)\")\np2 = plot(xlims=(0,20), xlabel=\"k\", ylabel=\"c(k)\")\nfor M in [1000, 100, 50]\n    dr = Rmax/M\n    sol  = @time solve(system, closure, NgIteration(M=M, dr=dr))\n    kmax = round(maximum(sol.k), digits=2)\n    plot!(p1, sol.r, sol.cr, label=\"M=$M, kmax=$(kmax)\", ls=:dash, markers=:o, legend=false)\n    plot!(p2, sol.k, sol.ck, label=\"M=$M, kmax=$(kmax)\", ls=:dash, markers=:o, legend=:bottomright)\nend\ndisplay(plot(p1,p2))\n\nHere the coarse grid under-resolves oscillations in (c(r)) and doesn't capture it's decay in Fourier space, which in turn leads to distorted structure factors (S(k)).","category":"section"},{"location":"ExtendingPotentials.html#Defining-your-own-potentials","page":"Defining your own potentials","title":"Defining your own potentials","text":"Creating your own potentials type is very easy. We can do this by making use of the CustomPotential","category":"section"},{"location":"ExtendingPotentials.html#Example","page":"Defining your own potentials","title":"Example","text":"We want to implement the interaction potential  u(r) = epsilon left(fracsigmarright)^6\n\nTo do this, first we define the function. This function should take two arguments, r::Number and p, the latter of which contains optional parameters that the function uses. For example:\n\nfunction my_pot(r, p)\n    return p.ϵ * (p.σ / r)^6\nend\n\nNow we can instantiate the CustomPotential, using e.g. a NamedTuple to pass in the parameters:\n\nusing OrnsteinZernike\np = (ϵ = 1.0, σ = 1.0)\npotential = CustomPotential(my_pot, p)\n\nAnd use the potential as any other \n\ndims = 3 # we consider a 3D system\nρ = 0.6 # number density\nkBT = 1.0 # thermal energy\nsystem = SimpleFluid(dims, ρ, kBT, potential)\nclosure = HypernettedChain()\nsol = solve(system, closure)\nusing Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\")","category":"section"},{"location":"ExtendingPotentials.html#Mixtures","page":"Defining your own potentials","title":"Mixtures","text":"In the case of multicomponent systems, instead of a number the function should return a StaticMatrix from the StaticArrays package containing values for u_ij. ","category":"section"},{"location":"ExtendingPotentials.html#Example-2","page":"Defining your own potentials","title":"Example","text":"Suppose we want to implement the same potential for the multicomponent case: u_ij(r) = epsilon_ij (fracsigma_ijr_ij)^6\n\nWhile one could implement this in one line with broadcasting, here the function is written out fully for clarity:\n\nusing OrnsteinZernike, StaticArrays \n\nfunction mypotential(r, p)\n    # we can construct a mutable sized matrix first\n    Nspecies = size(p.ϵ, 1)\n    out = MMatrix{Nspecies, Nspecies, Float64, Nspecies*Nspecies}(undef) \n    for species2 = 1:Nspecies\n        for species1 = 1:Nspecies\n            out[species1, species2] = p.ϵ[species1, species2] * (p.σ[species1, species2] / r) ^ 6\n        end\n    end\n    # and convert it to an immutable variant\n    return SMatrix(out) \nend\n\nand now we can use it:\n\nϵ = SMatrix{2,2}([1.0 2.0; 0.4 0.9])\nσ = SMatrix{2,2}([1.0 1.0; 1.0 0.8])\np = (ϵ = ϵ, σ = σ)\ndims = 3 # we consider a 3D system\npotential = CustomPotential(mypotential, p)\nρ = [0.25, 0.25] # number density\nkBT = 1.0 # thermal energy\nsystem = SimpleMixture(dims, ρ, kBT, potential)\nclosure = HypernettedChain()\nsol = solve(system, closure)\nusing Plots\nplot(sol.r, sol.gr[:, 1, 1], xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", label=\"g11(r)\")\nplot!(sol.r, sol.gr[:, 1, 2], xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", label=\"g12(r)\")\nplot!(sol.r, sol.gr[:, 2, 2], xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", label=\"g22(r)\")","category":"section"},{"location":"ThermodynamicConsistency.html#Thermodynamic-Consistency","page":"Thermodynamic Consistency","title":"Thermodynamic Consistency","text":"Some Closures have free parameters that can be tuned to obtain the most accurate bridge functions. For example, the famous Rogers-Young closure RogersYoung interpolates between the Percus-Yevick closure and the Hypernetted Chain one with a free parameter alpha. While this parameter can be chosen freely, it is usually chosen such that the solutions satisfy thermodynamic consistency. ","category":"section"},{"location":"ThermodynamicConsistency.html#Free-choice-of-\\alpha","page":"Thermodynamic Consistency","title":"Free choice of alpha","text":"To warm up, let's solve a 3D hard-sphere system for alpha=05\n\nusing OrnsteinZernike, Plots\nM = 5000\nρ = 0.6 * sqrt(2)\ndr = 20.0/M\nkBT = 1.0\ndims = 3 \nα = 0.5\npot = HardSpheres(1.0)\nsystem = SimpleFluid(dims, ρ, kBT, pot)\nmethod = NgIteration(M=M, dr=dr, verbose=false)\nsolRY = solve(system, RogersYoung(α), method)\nsolPY = solve(system, PercusYevick(), method)\nsolHNC = solve(system, HypernettedChain(), method)\n\nplot(solRY.r, solRY.gr, label=\"Rogers-Young\")\nplot!(solPY.r, solPY.gr, label=\"Percus-Yevick\")\nplot!(solHNC.r, solHNC.gr, label=\"Hypernetted Chain\")\nplot!(xlims=(0.9,2.3), xlabel=\"r\", ylabel=\"g(r)\")\n\nHere, we can see, that indeed, the Rogers-Young closure finds a middle ground between the two others. ","category":"section"},{"location":"ThermodynamicConsistency.html#Using-thermodynamics","page":"Thermodynamic Consistency","title":"Using thermodynamics","text":"There are a number of thermodynamic relations that allow a consistent choice of alpha. Here we opt for the requirement frac1rhochi_T=left(fracpartial ppartial rhoright)_T, which physically means that we require the virial and compressibility route of obtaining the pressure to give the same results. For simplicity, we use finite differences to obtain the derivative of the pressure. See the Theory section for more details. Subsequently, we use the bisection method from Roots.jl to find the optimal parameter. The results can be compared to Table 1 in Ref. 1. \n\nusing OrnsteinZernike, Plots\nimport Roots\nfunction find_self_consistent_solution(ρ, kBT, M, dr, dims, pot)\n\n    function RY_inconsistency(ρ, α)\n        system1 = SimpleFluid(dims, ρ, kBT, pot)\n        method = NgIteration(M=M, dr=dr, verbose=false)\n        sol1 = solve(system1, RogersYoung(α), method)\n        p1 = compute_virial_pressure(sol1, system1)\n\n        dρ = sqrt(eps(ρ))\n        system2 = SimpleFluid(dims, ρ+dρ, kBT, pot)\n        sol2 = solve(system2, RogersYoung(α), method)\n        p2 = compute_virial_pressure(sol2, system2)\n        dpdρ = (p2-p1)/dρ\n\n        χ = compute_compressibility(sol1, system1)\n        inconsistency = dpdρ - 1/(ρ*χ)\n        return inconsistency\n    end\n\n    # we need to find α such that the inconsistency is zero.\n    func = α ->  RY_inconsistency(ρ, α)\n    α =  Roots.find_zero(func, (0.001,50.0), Roots.Bisection(), atol=0.0001)\n    system = SimpleFluid(dims, ρ, kBT, pot)\n    method = NgIteration(M=M, dr=dr, verbose=false)\n    sol = solve(system, RogersYoung(α), method)\n    return system, sol, α\nend\n\nfor ρstar = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.654]\n    ρ = ρstar*sqrt(2)\n    M = 1000\n    dr = 10.0/M\n    kBT = 1.0\n    dims = 3 \n    pot = HardSpheres(1.0)\n    system, sol, α = find_self_consistent_solution(ρ, kBT, M, dr, dims, pot)\n    P = compute_virial_pressure(sol, system)/ρ/kBT - 1\n    gmax = maximum(sol.gr)\n    println(\"At ρ/√2 = $(ρstar), we find α = $(round(α,digits=2)), and βp/ρ - 1 = $(round(P,digits=4)).\")\nend\n\nReferences:\n\nRogers, Forrest J., and David A. Young. \"New, thermodynamically consistent, integral equation for simple fluids.\" Physical Review A 30.2 (1984): 999.","category":"section"},{"location":"Systems.html#Systems","page":"Systems","title":"Systems","text":"A System describes what you want to solve: dimensionality, density, temperature, and the interaction potential.   The package exports two neutral system types and two charged wrappers:\n\nSimpleFluid — single component\nSimpleMixture — multi-component (mixtures)\nSimpleChargedFluid — one-component plasma (OCP): a single mobile charged species in a uniform neutralizing background\nSimpleChargedMixture — electrolyte mixture: multiple mobile charged species (no background; must be electroneutral)\n\ntip: Choosing a system\nType Components ρ (density) input evaluate_potential return\nSimpleFluid 1 Number Number\nSimpleMixture ≥ 2 AbstractVector (length = Ns) Ns×Ns matrix (e.g. SMatrix)\nSimpleChargedFluid 1 + background (in base) (from base)\nSimpleChargedMixture ≥ 2 (in base) (from base)\n\nInternally, for mixtures the density vector is stored as a diagonal matrix with StaticArrays.SVector storage for performance.\n\n","category":"section"},{"location":"Systems.html#SimpleFluid","page":"Systems","title":"SimpleFluid","text":"SimpleFluid assumes rotationally symmetric pair interactions (depend only on the center-to-center distance) and no external field.","category":"section"},{"location":"Systems.html#Example:-2D-Lennard–Jones-(single-component)","page":"Systems","title":"Example: 2D Lennard–Jones (single component)","text":"using OrnsteinZernike\npotential = LennardJones(1.0, 1.0)  # ϵ=1, σ=1\nkBT = 1.0\nρ   = 0.5\ndims = 2\nsystem = SimpleFluid(dims, ρ, kBT, potential)\n\n","category":"section"},{"location":"Systems.html#SimpleMixture","page":"Systems","title":"SimpleMixture","text":"SimpleMixture is for multi-component systems. Pass a vector of species densities; the potential must evaluate to an Ns×Ns matrix giving all pair interactions.\n\nnote: Note\nThe density vector ρ::AbstractVector is converted to Diagonal(SVector{Ns}(ρ)) internally.","category":"section"},{"location":"Systems.html#Example:-3D-10-component-hard-sphere-mixture","page":"Systems","title":"Example: 3D 10-component hard-sphere mixture","text":"using OrnsteinZernike # hide\nD        = collect(0.1:0.1:1.0)        # species diameters\npotential = HardSpheres(D)\nkBT = 1.0\nρ   = fill(0.1, 10)                     # number densities per species\ndims = 3\nsystem = SimpleMixture(dims, ρ, kBT, potential)\n\n","category":"section"},{"location":"Systems.html#Charged-systems","page":"Systems","title":"Charged systems","text":"","category":"section"},{"location":"Systems.html#SimpleChargedFluid-—-One-Component-Plasma-(OCP)","page":"Systems","title":"SimpleChargedFluid — One-Component Plasma (OCP)","text":"SimpleChargedFluid models a single mobile charged species embedded in a uniform neutralizing background (“jellium”).   This means you do not need a counter-ion species: electroneutrality is enforced by the background.\n\nBackground charge density is implicitly ρ_bg = − ρ · z (not mobile, not part of the potential; it only neutralizes and fixes the small-k behavior).\nDebye screening uses mobile charges only: κ_D^2 = 4π ℓ_B ρ z^2 (in 3D reduced units).\nThe solver handles the k→0 Coulomb singularity via an Ewald-like split; background terms cancel the divergent constants so structure is well-defined.\nUse SimpleChargedMixture instead if you want explicit co-/counter-ions (no background, mixture must be electroneutral).","category":"section"},{"location":"Systems.html#Example:-3D-classical-OCP-(hard-sphere-core-Coulomb-neutralizing-background)","page":"Systems","title":"Example: 3D classical OCP (hard-sphere core + Coulomb + neutralizing background)","text":"using OrnsteinZernike # hide\ndims = 3\nρ    = 0.5\nkBT  = 1.0\ncore = HardSpheres(1.0)                 # short-range core (optional)\nbase = SimpleFluid(dims, ρ, kBT, core)\n\n# OCP: single species of charge z in a uniform neutralizing background\nz    = 1.0\nlB = 7.0                                # Bjerrum length\nsys  = SimpleChargedFluid(base, z, lB)  # κ chosen automatically (Debye)\n\n# Now use closures/solvers as usual:\n# sol = solve(sys, HypernettedChain(); method=NgIteration(M=2000, dr=0.01))","category":"section"},{"location":"Systems.html#SimpleChargedMixture-—-Electrolyte-mixtures","page":"Systems","title":"SimpleChargedMixture — Electrolyte mixtures","text":"SimpleChargedMixture wraps a neutral SimpleMixture and adds per-species charges z.   No background is added; the system must satisfy electroneutrality ∑ᵢ ρᵢ zᵢ ≈ 0.","category":"section"},{"location":"Systems.html#Example:-3D-1:1-restricted-primitive-model-(RPM)","page":"Systems","title":"Example: 3D 1:1 restricted primitive model (RPM)","text":"using OrnsteinZernike # hide\ndims = 3\nρ    = [0.3, 0.3]                      # mobile species densities\nkBT  = 1.0\nhs   = HardSpheres([1.0, 1.0])         # per-species diameters (short-range)\nbase = SimpleMixture(dims, ρ, kBT, hs)\n\nz    = [ 1.0, -1.0 ]                   # charges (must be electroneutral with ρ)\nlB = 7.0                               # Bjerrum length\nsys  = SimpleChargedMixture(base, z, lB) \n\n","category":"section"},{"location":"Systems.html#Backward-compatibility","page":"Systems","title":"Backward compatibility","text":"The old SimpleLiquid constructors are still available as deprecated aliases:\n\nSimpleLiquid(dims, ρ::Number, kBT, potential) → SimpleFluid\nSimpleLiquid(dims, ρ::Vector, kBT, potential) → SimpleMixture\n\nYou’ll see a deprecation warning; please migrate to the new names.\n\n","category":"section"},{"location":"Systems.html#Common-pitfalls","page":"Systems","title":"Common pitfalls","text":"Density/potential mismatch:   If ρ is a vector of length Ns, then evaluate_potential(potential, r) must return an Ns×Ns matrix (e.g., SMatrix{Ns,Ns}).\nUnits:   Ensure the potential and kBT are in consistent reduced units.\nFor OCP (SimpleChargedFluid):   Remember the neutralizing background is implicit and non-mobile; use mixtures if you need explicit counter-ions.\nFor SimpleChargedMixture:   The mixture must be electroneutral: ∑ᵢ ρᵢ zᵢ ≈ 0.","category":"section"},{"location":"Systems.html#OrnsteinZernike.SimpleFluid","page":"Systems","title":"OrnsteinZernike.SimpleFluid","text":"SimpleFluid{dims,Tρ,TkT,P} <: AbstractSingleComponent\n\nHomogeneous, isotropic single-component system with a scalar-valued potential.\n\nConstruct with:\n\nSimpleFluid(dims, ρ::Number, kBT, potential)\n\njulia\n\nFields:\n\nρ::Number       — number density\nkBT             — thermal energy\npotential::P    — scalar-valued interaction potential (evaluate_potential(potential, r)::Number)\n\n\n\n\n\n","category":"type"},{"location":"Systems.html#OrnsteinZernike.SimpleMixture","page":"Systems","title":"OrnsteinZernike.SimpleMixture","text":"SimpleMixture{dims,Ns,Tρ,TkT,P} <: AbstractMixture\n\nHomogeneous, isotropic mixture with a matrix-valued potential.\n\nConstruct with:\n\nSimpleMixture(dims, ρ::AbstractVector, kBT, potential)\n\njulia\n\nNotes:\n\nρ is converted to a diagonal matrix with StaticArrays.SVector storage (as before).\nevaluate_potential(potential, r) must return an Ns×Ns matrix (e.g., StaticArrays.SMatrix{Ns,Ns}).\n\n\n\n\n\n","category":"type"},{"location":"Systems.html#OrnsteinZernike.SimpleChargedFluid","page":"Systems","title":"OrnsteinZernike.SimpleChargedFluid","text":"SimpleChargedFluid{dims,Tρ,TkT,P,Tz} <: AbstractSingleComponent\n\nSingle-component electrolyte wrapper (one-component plasma). Keeps electrostatics (charges, Bjerrum length, split κ) as system-level state; short-range/core physics remain in potential.\n\nFields:\n\nbase::SimpleFluid  — underlying neutral single-component system\nz::Tz              — charge (in units of e)\nℓB::Float64        — Bjerrum length (in your length units)\nCd::Float64       — surface area constant for the dimension (4π, 2π, 2) for d = 3, 2, 1\n\n\n\n\n\n","category":"type"},{"location":"Systems.html#OrnsteinZernike.SimpleChargedMixture","page":"Systems","title":"OrnsteinZernike.SimpleChargedMixture","text":"SimpleChargedMixture{dims,Ns,Tρ,TkT,P,Tz} <: AbstractMixture\n\nMixture electrolyte wrapper. Electrostatics live on the system; potentials remain short-range.\n\nFields:\n\nbase::SimpleMixture — underlying neutral mixture\nz::SVector{Ns,Tz}   — per-species charges\nℓB::Float64         — Bjerrum length\nCd::Float64       — surface area constant for the dimension (4π, 2π, 2) for d = 3, 2, 1\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#Closures","page":"Closures","title":"Closures","text":"This package defines several closure relations that can be used out of the box. It is straightforward to implement your own closure, see Defining your own closure. \n\nSome closures, for example the Rogers-Young closure, include free parameters that may be fixed by the requirement of thermodynamic consistency. See the Thermodynamic Consistency page for an example. \n\nSome closures use a renormalized indirect correlation function gamma^*(r) = gamma(r) - u_LR(r) instead of the standard one. Here, u_LR(r) is the long-range tail of the interaction potential. The solver now makes this choice explicit: each closure advertises whether it wants gamma^* via the trait uses_renormalized_gamma(closure), and each potential exposes its dispersion tail through dispersion_tail(potential, kBT, r, βu). When a closure opts in, the appropriate tail is subtracted automatically before the bridge function is evaluated. If a renormalised-γ closure is paired with a potential that does not expose such a tail, the solver emits an error suggesting to wrap the potential in WCADivision(...) (Weeks–Chandler–Andersen split) or AllShortRangeDivision(...) (explicitly mark the interaction as fully short ranged). ","category":"section"},{"location":"Closures.html#Dispersion-handling-in-practice","page":"Closures","title":"Dispersion handling in practice","text":"When you pick a closure for which uses_renormalized_gamma returns true (the SMSA/HMSA family, Lee, Duh–Haymet, etc.) you must present the solver with a potential that splits into short- and long-ranged pieces. You can do this in two ways:\n\nWrap the base interaction in WCADivision(potential, r_c) to obtain the traditional Weeks–Chandler–Andersen short-range/dispersion tail separation.\nMark it as fully short ranged via AllShortRangeDivision(potential) so the solver knows that the dispersion tail is zero.\n\nFailing to do so raises an error before the iteration starts. For example:\n\nusing OrnsteinZernike\nclosure = ZerahHansen()              # expects γ* = γ - βuₗᵣ\nlj       = LennardJones(1.0, 1.0)\nfluid    = SimpleFluid(3, 0.4, 1.0, lj)\n\n# this throws: closure needs a dispersion split\n# solve(fluid, closure, NgIteration())\n\n# add a WCA split and the run succeeds\nwca_fluid = SimpleFluid(3, 0.4, 1.0, WCADivision(lj, 2^(1/6)))\nsol = solve(wca_fluid, closure, NgIteration())\n\nFor charged systems, the charges are always dealt with analytically. They are not included in the dispersion tails.","category":"section"},{"location":"Closures.html#Implemented-Closures","page":"Closures","title":"Implemented Closures","text":"Below is an alphabetical list of implemented closures. We use the notation shown in the Theory section.\n\nModules = [OrnsteinZernike]\nPages = [\"Closures.md\"]\nOrder   = [:type]\nPrivate = false","category":"section"},{"location":"Closures.html#OrnsteinZernike.BallonePastoreGalliGazzillo","page":"Closures","title":"OrnsteinZernike.BallonePastoreGalliGazzillo","text":"BallonePastoreGalliGazzillo <: Closure\n\nImplements the Ballone-Pastore-Galli-Gazzillo closure b(r) = (1 + s gamma(r))^1s - gamma(r) - 1  Here s is a free parameter that can be determined with thermodynamic consistency.\n\nExample:\n\nclosure = BallonePastoreGalliGazzillo(1.5)\n\nReferences:\n\nBallone, P., et al. \"Additive and non-additive hard sphere mixtures: Monte Carlo simulation and integral equation results.\" Molecular Physics 59.2 (1986): 275-290.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.BomontBretonnet","page":"Closures","title":"OrnsteinZernike.BomontBretonnet","text":"BomontBretonnet <: Closure\n\nImplements the Bomont-Bretonnet closure b(r) = sqrt1+2gamma^*(r) + f gamma^*(r)^2 - gamma^*(r) - 1   Here  gamma^* = gamma - u_LR , in which $ u_{LR}$ is the long range tail of the potential, and f is a free parameter that can be determined with thermodynamic consistency.\n\nExample:\n\nclosure = BomontBretonnet(0.5)\n\nReferences:\n\nBomont, J. M., and J. L. Bretonnet. \"A self-consistent integral equation: Bridge function and thermodynamic properties for the Lennard-Jones fluid.\" The Journal of chemical physics 119.4 (2003): 2188-2191.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.CarbajalTinoko","page":"Closures","title":"OrnsteinZernike.CarbajalTinoko","text":"CarbajalTinoko <: Closure\n\nImplements the Carbajal-Tinoko closure e(ralpha)left(2-y(r))e^y(r)-2-y(r)rightleft(e^y(r)-1right) where e(ralpha)=3exp(alpha r) for alpha 0 and e(ralpha) = 3+alpha otherwise.\n\nExample:\n\nclosure = CarbajalTinoko(0.4)\n\nReferences:\n\nCarbajal-Tinoco, Mauricio D. \"Thermodynamically consistent integral equation for soft repulsive spheres.\" The Journal of chemical physics 128.18 (2008).\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.CharpentierJackse","page":"Closures","title":"OrnsteinZernike.CharpentierJackse","text":"CharpentierJackse <: Closure\n\nImplements the Charpentier-Jackse closure b(r) = frac12alphaleft(sqrt1+4alphagamma^*(r)  - 2alphagamma^*(r) - 1right)  Here  gamma^* = gamma - u_LR , in which $ u_{LR}$ is the long range tail of the potential, and alpha is a free parameter that  can be determined with thermodynamic consistency.\n\nExample:\n\nclosure = CharpentierJackse(0.5)\n\nReferences:\n\nCharpentier, I., and N. Jakse. \"Exact numerical derivatives of the pair-correlation function of simple liquids using the tangent linear method.\" The Journal of Chemical Physics 114.5 (2001): 2284-2292.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.ChoudhuryGhosh","page":"Closures","title":"OrnsteinZernike.ChoudhuryGhosh","text":"ChoudhuryGhosh <: Closure\n\nImplements the Choudhury-Ghosh closure b(r) = -frac-gamma^*(r)^22(1+alpha gamma^*(r))  for gamma^*(r) 0, and b(r)=-gamma^*(r)^22 otherwise. Here  gamma^* = gamma - u_LR , in which $ u_{LR}$ is the long range tail of the potential, and alpha is a free parameter that  is determined by an empirical relation.\n\nExample:\n\nα(ρ) = 1.01752 - 0.275ρ # see the reference for this empirical relation\nclosure = ChoudhuryGhosh(α(0.4))\n\nReferences:\n\nChoudhury, Niharendu, and Swapan K. Ghosh. \"Integral equation theory of Lennard-Jones fluids: A modified Verlet bridge function approach.\" The Journal of chemical physics 116.19 (2002): 8517-8522.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.DuhHaymet","page":"Closures","title":"OrnsteinZernike.DuhHaymet","text":"DuhHaymet <: Closure\n\nImplements the Duh-Haymet closure b(r) = frac-gamma^*(r)^22left1+left(frac5gamma^*(r)+117gamma^*(r)+9right)gamma^*(r)right  for gamma^*(r) 0, and b(r)=-gamma^*(r)^22 otherwise. Here  gamma^* = gamma - u_LR , in which $ u_{LR}$ is the long range tail of the potential, \n\nExample:\n\nclosure = DuhHaymet()\n\nReferences:\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.ExtendedRogersYoung","page":"Closures","title":"OrnsteinZernike.ExtendedRogersYoung","text":"ExtendedRogersYoung <: Closure\n\nImplements the extended Rogers-Young closure b(r) = ln(aphi(r)^2 +  phi(r) + 1) - γ(r)   Here phi(r) = fracexp(f(r)gamma(r)) - 1f(r), and f(r)=1-exp(-alpha r), in which alpha is a free parameter,  that may be chosen such that thermodynamic consistency is achieved. Example:\n\nclosure = ExtendedRogersYoung(0.5, 0.5) # order is α, a\n\nReferences: J. Chem. Phys. 128, 184507 (2008)\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.HypernettedChain","page":"Closures","title":"OrnsteinZernike.HypernettedChain","text":"HypernettedChain\n\nImplements the Hypernetted Chain closure c(r) = (f(r)+1)exp(gamma(r)) - gamma(r) - 1, or equivalently b(r) = 0.\n\nExample:\n\nclosure = HypernettedChain()\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.Khanpour","page":"Closures","title":"OrnsteinZernike.Khanpour","text":"Khanpour <: Closure\n\nImplements the Khanpour closure b(r) = frac1alphaln(1+alphagamma(r)) - gamma   Here alpha is a free parameter that can be determined with thermodynamic consistency.\n\nExample:\n\nclosure = Khanpour(0.5)\n\nReferences:\n\nKhanpour, Mehrdad. \"A unified derivation of Percus–Yevick and hyper-netted chain integral equations in liquid state theory.\" Molecular Physics 120.5 (2022): e2001065.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.Lee","page":"Closures","title":"OrnsteinZernike.Lee","text":"Lee <: Closure\n\nImplements the Lee closure b(r) = -fraczetagamma^*(r)^22 left( 1- fracphi alpha gamma^*(r)1 + alphagamma^*(r) right)  Here  gamma^* = gamma + ρ f(r)2 , in which $ f(r)$ is the Mayer-f function and rho the density. Additionally, zeta,phi, and, alpha are free parameters that  can be determined with thermodynamic consistency or zero-separation theorems.\n\nExample:\n\nclosure = Lee(1.073, 1.816, 1.0, 0.4) # ζ, ϕ, α, ρ\n\nReferences:\n\nLee, Lloyd L. \"An accurate integral equation theory for hard spheres: Role of the zero‐separation theorems in the closure relation.\" The Journal of chemical physics 103.21 (1995): 9388-9396.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.MartynovSarkisov","page":"Closures","title":"OrnsteinZernike.MartynovSarkisov","text":"MartynovSarkisov <: Closure\n\nImplements the Martynov-Sarkisov Closure b(r) = -sqrt1+2gamma-1-gamma, which is constructed for the 3d hard-sphere liquid.\n\nExample:\n\nclosure = MartynovSarkisov()\n\nReferences:\n\nMartynov, G. A., and G. N. Sarkisov. \"Exact equations and the theory of liquids. V.\" Molecular Physics 49.6 (1983): 1495-1504.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.ModifiedHypernettedChain","page":"Closures","title":"OrnsteinZernike.ModifiedHypernettedChain","text":"ModifiedHypernettedChain <: Closure\n\nImplements the Modified Hypernetted Chain closure b(r) = b_HS(r)  Here b_HS(rσ)=left((a_1+a_2x)(x-a_3)(x-a_4)(a_3 a_4)right)^2 for xa_4 and b_HS(r)=left(A_1 exp(-a_5(x-a_4))sin(A_2(x-a_4))rright)^2 is the hard sphere bridge function found in Malijevský & Labík. The parameters are defined as\n\nx = rσ-1\n\nA_1 = (a_1+a_2 a_4)(a_4-a_3)(a_4+1)(A_2 a_3 a_4)\n\nA_2 =  pi  (a_6 - a_4 - 1)\n\na_1 = eta (155707 - 185633eta)  (1-eta)^2\n\na_2 = eta (128127 - 182134eta)  (1-eta)\n\na_3 =  (074480 - 093453eta)\n\na_4 = (117102 - 068230eta)\n\na_5 = 015975eta^2\n\na_6 = (269757 - 086987eta)\n\nand eta is the volume fraction of the hard sphere reference system. This closure only works for single component systems in three dimensions. By default, sigma = 10.\n\nExample:\n\nclosure = ModifiedHypernettedChain(0.4)\nclosure = ModifiedHypernettedChain(0.4; sigma=0.8)\n\nReferences:\n\nLado, F. \"Perturbation correction for the free energy and structure of simple fluids.\" Physical Review A 8.5 (1973): 2548.\n\nMalijevský, Anatol, and Stanislav Labík. \"The bridge function for hard spheres.\" Molecular Physics 60.3 (1987): 663-669.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.ModifiedVerlet","page":"Closures","title":"OrnsteinZernike.ModifiedVerlet","text":"ModifiedVerlet <: Closure\n\nImplements the modified Verlet Closure b(r) = -fracgamma^2(r)21+alpha gamma(r). If gamma(r)0, the closure reads -gamma^22. Example:\n\nclosure = ModifiedVerlet(0.2)\n\nReferences:\n\nVerlet, Loup. \"Integral equations for classical fluids: I. The hard sphere case.\" Molecular Physics 41.1 (1980): 183-190.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.PercusYevick","page":"Closures","title":"OrnsteinZernike.PercusYevick","text":"PercusYevick\n\nImplements the Percus-Yevick closure c(r) = f(r)(1+gamma(r)), or equivalently b(r) = ln(1 + gamma(r)) - γ(r).\n\nExample:\n\nclosure = PercusYevick()\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.RogersYoung","page":"Closures","title":"OrnsteinZernike.RogersYoung","text":"RogersYoung <: Closure\n\nImplements the Rogers-Young closure b(r) = ln(fracexp(f(r)gamma(r)) - 1f(r) + 1) - γ(r)   Here f(r)=1-exp(-alpha r), in which alpha is a free parameter,  that may be chosen such that thermodynamic consistency is achieved. Example:\n\nclosure = RogersYoung(0.5)\n\nReferences: Rogers, Forrest J., and David A. Young. \"New, thermodynamically consistent, integral equation for simple fluids.\" Physical Review A 30.2 (1984): 999.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.SMSA","page":"Closures","title":"OrnsteinZernike.SMSA","text":"SMSA <: Closure\n\nImplements the soft-core mean spherical closure b(r) = ln(gamma^*(r) + 1) - gamma^*(r). Here gamma^* = gamma - u_LR , in which u_LR is the long range tail of the potential.\n\nExample:\n\nclosure = SMSA()\n\nReferences:\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.Verlet","page":"Closures","title":"OrnsteinZernike.Verlet","text":"Verlet <: Closure\n\nImplements the Verlet Closure b(r) = -fracAgamma^2(r)21+B gamma(r)2, where by default A=1 and B=85. These values are tuned by the virial coefficients of the 3d hard sphere liquid.\n\nExample:\n\nclosure = Verlet()\nclosure = Verlet(A=3.0, B=4.0)\n\nReferences:\n\nVerlet, Loup. \"Integral equations for classical fluids: I. The hard sphere case.\" Molecular Physics 41.1 (1980): 183-190.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.VompeMartynov","page":"Closures","title":"OrnsteinZernike.VompeMartynov","text":"VompeMartynov <: Closure\n\nImplements the Vompe-Martynov closure b(r) = sqrt1+2gamma^*(r)  - gamma^*(r) - 1  Here  gamma^* = gamma - u_LR , in which $ u_{LR}$ is the long range tail of the potential, and alpha is a free parameter that can be determined with thermodynamic consistency.\n\nExample:\n\nclosure = VompeMartynov()\n\nReferences:\n\nVompe, A. G., and G. A. Martynov. \"The bridge function expansion and the self‐consistency problem of the Ornstein–Zernike equation solution.\" The Journal of chemical physics 100.7 (1994): 5249-5258.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.ZerahHansen","page":"Closures","title":"OrnsteinZernike.ZerahHansen","text":"ZerahHansen <: Closure\n\nImplements the Zerah-Hansen (HMSA) (HNC-SMSA) closure b(r) = ln(fracexp(f(r)gamma^*(r)) - 1f(r) + 1) - γ^*(r)  Here  gamma^* = gamma - u_LR , in which $ u_{LR}$ is the long range tail of the potential,  and f(r)=1-exp(-alpha r), in which alpha is a free parameter,  that may be chosen such that thermodynamic consistency is achieved.\n\nExample:\n\nclosure = ZerahHansen(0.5)\n\nReferences:\n\nZerah, Gilles, and Jean‐Pierre Hansen. \"Self‐consistent integral equations for fluid pair distribution functions: Another attempt.\" The Journal of chemical physics 84.4 (1986): 2336-2343.\n\n\n\n\n\n","category":"type"},{"location":"SingleCompLJ.html#First-steps","page":"First steps","title":"First steps","text":"In order to solve an Ornstein-Zernike equation, there are a number of things that need to be specified. \n\nThe interaction potential, \nThe system parameters: density, temperature and dimensionality\nThe closure relation\nThe solver\n\nLet's start with a very simple example: a three-dimensional 1-component system, where the particles interact according to an inverse power law potential u(r)=epsilon (sigmar)^n. In this case, we can make use of the built-in potential \n\nusing OrnsteinZernike\nϵ = 1.0\nσ = 1.0\nn = 8\npotential = InversePowerLaw(ϵ, σ, n)\n\nNow that we have the potential, we define the system\n\ndims = 3 # we consider a 3D system\nρ = 0.6 # number density\nkBT = 1.0 # thermal energy\nsystem = SimpleFluid(dims, ρ, kBT, potential)\n\nThe SimpleFluid object is meant to be used when dealing with systems that have spherically symmetric interaction potentials and no external fields. \n\nThe third step is to define a closure relation. For now, let's stick to the simple Hypernetted Chain closure\n\nclosure = HypernettedChain()\n\nWe can now solve the system. \n\nsol = solve(system, closure)\n\nNote that we have not specified the method by which we do so. In this case, a simple default method is chosen that works well in most cases.\n\nThe sol object contains fields for the radial distribution function gr, direct correlation function (in real and Fourier space) cr and ck, the static structure factor Sk, and arrays for r and k. For example, we can plot the radial distribution function as follows:\n\nusing Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\")\n\nFull code:\n\nusing OrnsteinZernike\nϵ = 1.0\nσ = 1.0\nn = 8\npotential = InversePowerLaw(ϵ, σ, n)\ndims = 3 # we consider a 3D system\nρ = 0.6 # number density\nkBT = 1.0 # thermal energy\nsystem = SimpleFluid(dims, ρ, kBT, potential)\nclosure = HypernettedChain()\nsol = solve(system, closure)\nusing Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\")","category":"section"},{"location":"ChargedSystems.html#Charged-Systems","page":"Charged Systems","title":"Charged Systems","text":"Charged fluids have long-ranged Coulomb interactions that require special handling in the Ornstein–Zernike (OZ) solver. This page explains the decomposition used in the code, how the short-ranged (SR) and long-ranged (LR) pieces are propagated through the OZ relations, and how the solver iterates to convergence.\n\n","category":"section"},{"location":"ChargedSystems.html#Field-Splitting:-Definitions-and-Notation","page":"Charged Systems","title":"Field Splitting: Definitions and Notation","text":"Potentials and correlation functions are consistently decomposed into short-ranged and long-ranged parts:\n\nPotential $ \\beta u{\\text{coul}} = \\underbrace{\\beta u{\\text{SR,coul}}}_{\\text{Coulomb SR split}}\n\\underbrace{\\beta u{\\text{LR,coul}}}{\\text{Coulomb LR split}}.\n$\nDirect correlation $ c = c{\\text{short\\range}} + \\Phi, \\qquad \\Phi \\equiv -\\,\\beta u_{\\text{LR,coul}}. $\nIndirect correlation $ \\gamma = \\gamma{\\text{short\\range}} + \\gamma{\\text{long\\range}}. $\nTotal correlation $ h = h{\\text{short\\range}} + q, $ where the LR part q is defined by the LR OZ relation in Fourier space: $ \\widehat{q}(k) = \\widehat{\\Phi} + \\widehat{\\Phi} \\rho \\widehat{q}(k). $\n\n","category":"section"},{"location":"ChargedSystems.html#Coulomb-Splitting-in-Practice","page":"Charged Systems","title":"Coulomb Splitting in Practice","text":"The Coulomb potential z_i z_j ell_B  r is split into SR and LR pieces by a user-selectable strategy. Other strategies can be easily implemented by a user.\n\nThe SR/LR split is produced by split_coulomb_potential(r, system, coulombsplitting).\n\nGiven Phi and its transform, the LR OZ part is solved analytically in k-space. This gives a fixed LR reference q used throughout the SR iteration.\n\n","category":"section"},{"location":"ChargedSystems.html#Minimal-Usage-Example:-1-3-electrolyte","page":"Charged Systems","title":"Minimal Usage Example: 1-3 electrolyte","text":"using OrnsteinZernike, StaticArrays, Plots\n\n# Define a (neutral) base mixture first\ndims = 3\nρ = [0.6, 0.2]              # number densities (reduced)\nZ = [1, -3]                 # charges\nℓB = 7.0                    # Bjerrum length (reduced)\n\npot = HardSpheres([1.0, 0.5])\nsys = SimpleMixture(dims, ρ, 1, pot)\n\n# Turn it into a charged mixture and choose a Coulomb splitting\ncharged = SimpleChargedMixture(sys, Z, ℓB)\n\nclosure = HypernettedChain()\nmethod  = FourierIteration(M=2048, dr=0.02, tolerance=1e-6, mixing_parameter=0.3)\n\n# Solve with an explicit splitting choice\nyour_solution = solve(charged, closure, method; coulombsplitting=EwaldSplitting(3.0))\n\n# Plot the unlike charges\ng12 = plot(your_solution.r, your_solution.gr[:, 1, 2], xlims=(0,3), label=\"g_{12}(r)\", xlabel=\"r\", ylabel=\"g(r)\")\nplot!(your_solution.r, your_solution.gr[:, 1, 1], label=\"g_{11}(r)\")\nplot!(your_solution.r, your_solution.gr[:, 2, 2], label=\"g_{22}(r)\")\n\nWe see that the unlike charges have a strong peak in g(r), and the highly negatively charged ions strongly repel.\n\nTip: If convergence is delicate, try:\n\nincreasing M (grid size) and/or decreasing dr,\nreducing the mixing_parameter or changing the number of stages if using NgIteration.","category":"section"},{"location":"API.html#The-OrnsteinZernike-Module","page":"API","title":"The OrnsteinZernike Module","text":"","category":"section"},{"location":"API.html#Module-Index","page":"API","title":"Module Index","text":"Modules = [OrnsteinZernike]\nOrder   = [:constant, :type, :function, :macro]\nPrivate = false","category":"section"},{"location":"API.html#Detailed-API","page":"API","title":"Detailed API","text":"","category":"section"},{"location":"API.html#OrnsteinZernike","page":"API","title":"OrnsteinZernike","text":"A generic solver package for Ornstein-Zernike equations from liquid state theory\n\n\n\n\n\n","category":"module"},{"location":"API.html#OrnsteinZernike.EwaldSplitting","page":"API","title":"OrnsteinZernike.EwaldSplitting","text":"EwaldSplitting(α) <: CoulombSplitting\n\nSplits the Coulomb potential into short-range and long-range parts using the Ewald splitting parameter α. Fields:\n\nα::Float64 : Ewald splitting  (inverse length scale)\n\nThe short-range part is given by:     ushortrange(r) = (zi * zj * ℓB / r) * erfc(α * r) The long-range part is given by:     ulongrange(r) = (zi * zj * ℓB / r) * erf(α * r)\n\n\n\n\n\n","category":"type"},{"location":"API.html#OrnsteinZernike.NoCoulombSplitting","page":"API","title":"OrnsteinZernike.NoCoulombSplitting","text":"NoSplitting <: CoulombSplitting\n\nNo splitting of the Coulomb potential; the entire Coulomb potential is treated as long range.\n\n\n\n\n\n","category":"type"},{"location":"API.html#OrnsteinZernike.OZSolution","page":"API","title":"OrnsteinZernike.OZSolution","text":"OZSolution\n\nHolds the solution of an Ornstein Zernike problem.\n\nFields:\n\nr: vector of distances\nk: vector of wave numbers\ngr: radial distribution function\nSk: static structure factor\nck: direct correlation function in k space\ncr: direct correlation function in real space\ngamma_r: indirect correlation function in real space\ngamma_k: indirect correlation function in k space\nconverged: whether the solution converged (always true; failures throw exceptions)\niterations: number of iterations performed\nfinal_error: final error at termination\ntermination_reason: reason for termination (:converged or :exact)\n\nif the system was a single-component system, gr, Sk, etc, are vectors. If instead the system was a multicomponent one, they are three dimensional vectors, where the first dimension contains the values along r, and the second and third dimension contain the data for the species.\n\n\n\n\n\n","category":"type"},{"location":"API.html#OrnsteinZernike.compute_compressibility-Tuple{OZSolution, Union{SimpleFluid, SimpleMixture}}","page":"API","title":"OrnsteinZernike.compute_compressibility","text":"compute_compressibility(sol::OZSolution, system::SimpleFluid)\n\nComputes the isothermal compressibility χ of the system\n\nuses the formula 1/ρkBTχ = 1 - ρ ĉ(k=0) for single component systems and 1/ρkBTχ = 1 - ρ Σᵢⱼ ĉᵢⱼ(k=0) for mixtures.  Eq. (3.6.16) in Hansen and McDonald\n\n\n\n\n\n","category":"method"},{"location":"API.html#OrnsteinZernike.compute_excess_energy-Tuple{OZSolution, OrnsteinZernike.System}","page":"API","title":"OrnsteinZernike.compute_excess_energy","text":"compute_excess_energy(sol::OZSolution,  system::SimpleUnchargedSystem)\n\nComputes the excess energy per particle Eₓ, such that E = (dims/2kBT + Eₓ)N.\n\nuses the formula Eₓ = 1/2 ρ ∫dr g(r) u(r) for single component systems and Eₓ = 1/2 ρ Σᵢⱼ xᵢxⱼ ∫dr gᵢⱼ(r) uᵢⱼ(r) for mixtures. Here x is the concentration fraction xᵢ=ρᵢ/sum(ρ).\n\n\n\n\n\n","category":"method"},{"location":"API.html#OrnsteinZernike.compute_virial_pressure-Tuple{OZSolution, Union{SimpleFluid, SimpleMixture}}","page":"API","title":"OrnsteinZernike.compute_virial_pressure","text":"compute_virial_pressure(sol::OZSolution,  system::SimpleUnchargedSystem)\n\nComputes the pressure via the virial route\n\nuses the formula p = kBTρ - 1/(2d) ρ^2 ∫dr r g(r) u'(r) for single component systems and p =  kBT Σᵢρᵢ - 1/(2d) Σᵢⱼ ρᵢρⱼ ∫dr r gᵢⱼ(r) u'ᵢⱼ(r) for mixtures.\n\nIt handles discontinuities in the interaction potential analytically if discontinuities(potential) is defined. For additional speed/accuracy define a method of evaluate_potential_derivative(potential, r::Number) that analytically computes du/dr.  By default this is done using finite differences.\n\n\n\n\n\n","category":"method"},{"location":"API.html#OrnsteinZernike.dispersion_tail-Tuple{OrnsteinZernike.Potential, Any, Number, Any}","page":"API","title":"OrnsteinZernike.dispersion_tail","text":"dispersion_tail(potential::Potential, kBT, r, βu)\n\nReturn the dispersion long-range contribution associated with potential. The default implementation returns zero, signalling that no tail is provided.\n\n\n\n\n\n","category":"method"},{"location":"API.html#OrnsteinZernike.solve","page":"API","title":"OrnsteinZernike.solve","text":"solve(system::System, closure::Closure, method::Method)\n\nSolves the system system using the closure closure with method method.\n\nsolve(system::System, closure::Closure)\n\nSolves the system system using the closure closure with the default method NgIteration().\n\n\n\n\n\n","category":"function"},{"location":"Mixtures.html#Mixtures-in-OrnsteinZernike.jl","page":"Mixtures in OrnsteinZernike.jl","title":"Mixtures in OrnsteinZernike.jl","text":"For a mixture with (N_s) species, the Ornstein–Zernike equation becomes matrix-valued:  \n\n[ h{ij}(r) = c{ij}(r) + \\sum{k=1}^{Ns} \\rhok \\, (c{ik} * h_{kj})(r) ]\n\nOutputs such as (g{ij}(r)), (S{ij}(k)), (c_{ij}(r)) are stored as 3D arrays:  \n\ngr[r, i, j] = pair distribution between species i and j.  \nSk[k, i, j] = partial structure factor between species i and j.\n\n","category":"section"},{"location":"Mixtures.html#Example:-Binary-Lennard–Jones-Mixture","page":"Mixtures in OrnsteinZernike.jl","title":"Example: Binary Lennard–Jones Mixture","text":"using OrnsteinZernike, Plots, StaticArrays\n\nρ = [0.3, 0.2]  # densities of species A and B\n\nfunction lj_matrix(r, params)\n    ϵ_AA, σ_AA, ϵ_BB, σ_BB, ϵ_AB, σ_AB = params\n    return SMatrix{2,2, Float64, 4}(\n        4*ϵ_AA*((σ_AA/r)^12 - (σ_AA/r)^6),  4*ϵ_AB*((σ_AB/r)^12 - (σ_AB/r)^6),\n        4*ϵ_AB*((σ_AB/r)^12 - (σ_AB/r)^6),  4*ϵ_BB*((σ_BB/r)^12 - (σ_BB/r)^6)\n    )\nend\n\npot = CustomPotential(lj_matrix, (1.0,1.0, 1.2,0.8, 1.1,0.9))\nsystem = SimpleMixture(3, ρ, 1.0, pot)\n\nsol = solve(system, HypernettedChain())\n\nplot(sol.r, sol.gr[:,1,1], label=\"g_AA(r)\")\nplot!(sol.r, sol.gr[:,1,2], label=\"g_AB(r)\")\nplot!(sol.r, sol.gr[:,2,2], label=\"g_BB(r)\")\n\n","category":"section"},{"location":"Mixtures.html#Interpretation","page":"Mixtures in OrnsteinZernike.jl","title":"Interpretation","text":"(g_{AA}(r)): correlations within species A  \n(g_{BB}(r)): correlations within species B  \n(g_{AB}(r)): cross-correlations  \n\nThese can be combined into total structure factors, or into Bhatia–Thornton components.","category":"section"},{"location":"HardSphereMixture.html#Hard-sphere-mixture","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"The previous example showed the case of a 1-component system. Let's instead look at mixtures here. Consider a 3:1 mixture of hard spheres with sizes 0.5 and 1.0. We solve the system with the same three steps as before.\n\nFirst, we define the potential. Here, we must use HardSpheres, which takes a vector containing the diameters of each species and applies an additive mixing rule. For more information see HardSpheres.\n\nusing OrnsteinZernike\nD = [0.5, 1.0]\npotential = HardSpheres(D)\n\nSecondly, we define the system. In this example, the total number density is rho = 16. For mixtures, the system expects a vector of individual densities. Those are computed by multiplying the total density with the concentration fractions.\n\nρ_total = 1.6\nρ = ρ_total*[0.75, 0.25] ## it is a 3:1 system\ndims = 3 # we consider a 3D system\nkBT = 1.0 # thermal energy\nsystem = SimpleMixture(dims, ρ, kBT, potential)\n\nThirdly, we define the closure\n\nclosure = PercusYevick()\n\nAnd now we solve the system. \n\nsol = solve(system, closure)\n\nFor mixtures, the fields sol.gr, sol.cr, sol.ck, and sol.Sk are now three-dimensional arrays with shape (Nr, Ns, Ns). For example, g_12(r_6) is stored in sol.gr[6,1,2].\n\nWe just solved the system using the default iterative solver NgIteration introduced by Ng. However, in this specific case, an exact solution is implemented. To use this, we specify the method Exact().\n\nmethod = Exact()\nsol_exact = solve(system, closure, method)\n\nLet's plot the resulting g(r). \n\nusing Plots\np = plot(sol.r, sol.gr[:, 1, 1], xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", lw=4, label=\"g11(r) iterative\")\nplot!(sol.r, sol.gr[:, 1, 2], xlabel=\"r\", ylabel=\"g(r)\", lw=4, label=\"g12(r) iterative\")\nplot!(sol.r, sol.gr[:, 2, 2], xlabel=\"r\", ylabel=\"g(r)\", lw=4, label=\"g22(r) iterative\")\nplot!(sol_exact.r, sol_exact.gr[:, 1, 1], lw=2, c=:black, label=\"exact\")\nplot!(sol_exact.r, sol_exact.gr[:, 1, 2], lw=2, c=:black, label=nothing)\nplot!(sol_exact.r, sol_exact.gr[:, 2, 2], lw=2, c=:black, label=nothing)\np","category":"section"},{"location":"OtherDimensions.html#Other-dimensions","page":"Other dimensions","title":"Other dimensions","text":"The solver is written for arbitrary dimension. This means that it is straightforward to solve  for other-than-three-dimensional systems. Let's for example solve the equations for hard (hyper)spheres in different dimensions, and see what the results look like\n\nusing OrnsteinZernike, Plots\ndensities = [0.8, 0.8, 0.8, 0.8, 0.8, 0.8]\ndimensionalities = Any[5, 4, 3, 2.21, 2, 1]\np = plot(xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\")\nfor i = 1:6\n    density  = densities[i]\n    dimension = dimensionalities[i]\n    potential = HardSpheres(1.0)\n    kBT = 1.0\n    system = SimpleFluid(dimension, density, kBT, potential)\n    closure = PercusYevick()\n    method = DensityRamp(NgIteration(), range(0.001, density-0.1, length=10))\n    sol = solve(system, closure, method)[end]\n    plot!(p, sol.r, sol.gr .+ i, label=\"d = $dimension\")\nend\np\n\n(Image: image)\n\nCurrently, however, noninteger dimensions below 2.0 are not supported.","category":"section"},{"location":"index.html#OrnsteinZernike.jl","page":"Index","title":"OrnsteinZernike.jl","text":"OrnsteinZernike.jl provides generic solvers for Ornstein-Zernike equations from liquid state theory.","category":"section"},{"location":"index.html#Installation","page":"Index","title":"Installation","text":"To install the package run \n\nimport Pkg\nPkg.add(\"OrnsteinZernike\")","category":"section"}]
}
