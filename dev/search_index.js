var documenterSearchIndex = {"docs":
[{"location":"HighDensities.html#Solving-at-high-densities","page":"Solving at high densities","title":"Solving at high densities","text":"","category":"section"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"Sometimes, especially when dealing with high densities, the solvers do not converge out-of-the-box. Typically, the easiest way to solve this is to initialize the iterative procedures with solutions of the same equation at a lower density. While this can be done by hand using the init keyword argument of the solve function, a convenient method DensityRamp is implemented to do this automatically. For example, consider a hard sphere system at ρ = 1.2.","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"using OrnsteinZernike\nρ = 1.2\nkBT = 1.0\ndims = 3\n\npot = SingleComponentHardSpheres()\nsystem = SimpleLiquid(dims, ρ, kBT, pot)\nclosure = PercusYevick()\nmethod = NgIteration()\nsol = solve(system, closure, method);","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"After iteration 0, the error is 114.96374587156.\nAfter iteration 10, the error is 246.47358557791.\nAfter iteration 20, the error is 48.60970316414.\n[...]\nAfter iteration 980, the error is 600.93302065646.\nAfter iteration 990, the error is 346.00914196416.\nAfter iteration 1000, the error is 78.17527233114.\nERROR: Recursive iteration did not converge within 1001 steps. Current error = 78.17527233113674.\n [1] error(s::String)\n   @ Base .\\error.jl:35\n[...]","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"To solve an issue like this, we can define DensityRamp method. This takes two arguments. The first is the actual method by which to solve the equations, which we leave as NgIteration() and the second is a list of densities to be evaluated before the target density.","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"densities = [0.7, 0.9, 1.0, 1.1]\nmethod2 = DensityRamp(method, densities)\nsol = @time solve(system, closure, method2);","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"Solving the system at ρ = 0.7.\n\nAfter iteration 0, the error is 3.7927462113.\nAfter iteration 10, the error is 0.02748002125.\nAfter iteration 20, the error is 2.459e-8.\nConverged after 25 iterations, the error is 8.0e-11.\n\nSolving the system at ρ = 0.9.\n\nAfter iteration 0, the error is 1.46229405321.\nAfter iteration 10, the error is 0.02624986205.\nAfter iteration 20, the error is 1.78285e-6.\nConverged after 29 iterations, the error is 3.0e-11.\n\nSolving the system at ρ = 1.0.\n\nAfter iteration 0, the error is 6.91022217054.\nAfter iteration 10, the error is 0.25666355675.\nAfter iteration 20, the error is 0.01233410847.\nAfter iteration 30, the error is 1.888465e-5.\nAfter iteration 40, the error is 1.94e-9.\nConverged after 44 iterations, the error is 8.0e-11.\n\nSolving the system at ρ = 1.1.\n\nAfter iteration 0, the error is 42.29810538999.\nAfter iteration 10, the error is 0.37566377791.\nAfter iteration 20, the error is 0.27554017425.\n[...].\nAfter iteration 70, the error is 1.555e-8.\nAfter iteration 80, the error is 5.2e-10.\nConverged after 84 iterations, the error is 5.0e-11.\n\nSolving the system at ρ = 1.2.\n\nAfter iteration 0, the error is 57.02991026895.\nAfter iteration 10, the error is 0.36390031646.\nAfter iteration 20, the error is 0.38501430163.\n[...]\nAfter iteration 110, the error is 2.706384e-5.\nAfter iteration 120, the error is 7.97e-7.\nAfter iteration 130, the error is 4.98e-9.\nConverged after 135 iterations, the error is 7.0e-11.\n  0.048063 seconds (1.86 k allocations: 1.330 MiB)","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"Let's plot and compare with the exact solution:","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"using OrnsteinZernike # hide\nρ = 1.2 # hide\nkBT = 1.0 # hide\ndims = 3 # hide\npot = SingleComponentHardSpheres() # hide\nsystem = SimpleLiquid(dims, ρ, kBT, pot) # hide\nclosure = PercusYevick() # hide\nmethod = NgIteration() # hide\ndensities = [0.7, 0.9, 1.0, 1.1] # hide\nmethod2 = DensityRamp(method, densities) # hide\nsol = solve(system, closure, method2); # hide\nusing Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", lw=4, label=\"iterative\")\n\nmethod3 = Exact()\nsol = solve(system, closure, method3);\nplot!(sol.r, sol.gr, lw=2, color=:black, label=\"exact\")","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"We can see that while the density is so high that g(r) shows a non-physical negative dip, it converged to the right mathematical solution. Note that this method will not always lead to convergence. For example, setting the density to ρ = 2.0 in this example, probably won't be correctly solved no matter how many intermediate densities are considered.","category":"page"},{"location":"ExtendingClosures.html#Defining-your-own-closure","page":"Defining your own closure","title":"Defining your own closure","text":"","category":"section"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"Creating your own closure type is very easy. It takes two steps. First, the type itself must be created, and secondly, one of the methods that evaluates the closure must be overloaded.","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"There are three options. One can overload either","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"bridge_function(closure, r, mayer_f, γ, u_long_range)\nclosure_c_from_gamma(closure, r, mayer_f, γ, u_long_range)\nclosure_cmulr_from_gammamulr(closure, r, mayer_f, γ, u_long_range)","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"Here, mayer_f is the Mayer-f function f(r) = exp(-beta u(r)) - 1, and u_long_range is the tail part of the potential, if the closure needs that. In practise, which of the three methods is overloaded can be arbitrary and depends on what is most convenient.","category":"page"},{"location":"ExtendingClosures.html#Example","page":"Defining your own closure","title":"Example","text":"","category":"section"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"Assume that we have forgotten that the HypernettedChain closure is already implemented, and we wanted to reimplement it. The hypernetted chain closure approximates c(r) approx (f(r)+1)exp(gamma(r)) - gamma(r) - 1, or equivalently b(r) approx 0.","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"First we define the type. Note that the new closure must be made a subtype of OrnsteinZernike.Closure","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"using OrnsteinZernike\n\nimport OrnsteinZernike.Closure\nstruct MyHNC <: Closure end","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"Now we can define how this closure should be evaluated. Here, we can for example either do","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"import OrnsteinZernike.bridge_function\nfunction OrnsteinZernike.bridge_function(::MyHNC, _, _, _, _)\n    return 0.0\nend","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"or","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"import OrnsteinZernike.closure_c_from_gamma\nfunction OrnsteinZernike.closure_c_from_gamma(::MyHNC, _, mayer_f, γ, _)\n    return (mayer_f + 1) * exp(γ) - γ - 1\nend","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"Now we can use the closure as any other ","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"ϵ = 1.0\nσ = 1.0\npotential = SingleComponentLennardJones(ϵ, σ)\ndims = 3 # we consider a 3D system\nρ = 0.01 # number density\nkBT = 1.0 # thermal energy\nsystem = SimpleLiquid(dims, ρ, kBT, potential)\nclosure = MyHNC()\nsol = solve(system, closure)\nusing Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\")","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"which can be compared to that of First steps.","category":"page"},{"location":"ExtendingClosures.html#Mixtures","page":"Defining your own closure","title":"Mixtures","text":"","category":"section"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"In the case of multicomponent systems, instead of a number the function that is overloaded should return a StaticMatrix containing either values for c_ij or b_ij. Since, in that case also the inputs are StaticMatrix, we can make use of Julia's broadcasting syntax to perform an closure elementwise. ","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"import OrnsteinZernike.closure_c_from_gamma\nfunction OrnsteinZernike.closure_c_from_gamma(::MyHNC, _, mayer_f, γ, _)\n    return @. (mayer_f + 1) * exp(γ) - γ - 1 # note the @.\nend","category":"page"},{"location":"Theory.html#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In this section, we describe our conventions and notation.","category":"page"},{"location":"Theory.html#Single-component-systems","page":"Theory","title":"Single component systems","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"The Ornstein zernike equation  h(r) = c(r) + rho int dtextbfr c(textbfr)h(textbfr - textbfr)  links the pair correlation function g(r) = h(r)+1 to the number density rho and the direct correlation function c(r). In order to solve it, a second relation between h(r) and c(r) must be specified. This is called the closure relation. ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In practise, the closure relation typically takes the form c(r) = f(gamma(r) r u(r)), where u(r) is the interaciton potential and gamma(r) = h(r) - c(r) is the indirect correlation function. Sometimes, instead the closure is defined for the bridge function b(r), and the closure relation is then given by h(r) - 1 = expleft(-beta u(r) + h(r) - c(r) + b(r) right), where beta = 1k_BT. ","category":"page"},{"location":"Theory.html#Mixtures","page":"Theory","title":"Mixtures","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Everything above generalizes to the mixture case:","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"The Ornstein zernike equation ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"h_ij(r) = c_ij(r) + sum_l rho_l int dtextbfr c_il(textbfr)h_lj(textbfr - textbfr) \n\nlinks the pair correlation function g_ij(r) = h_ij(r)+1","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"to the species specific number density rho_i and the direct correlation function c_ij(r). In order to solve it, a second relation between h_ij(r) and c_ij(r) must be specified. This is called the closure relation. ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In practise, the closure relation typically takes the form c_ij(r) = f(gamma_ij(r) r u_ij(r)), where u_ij(r) is the interaciton potential and gamma_ij(r) = h_ij(r) - c_ij(r) is the indirect correlation function. Sometimes, instead the closure is defined for the bridge function b(r), and the closure relation is then given by h_ij(r) - 1 = expleft(-beta u_ij(r) + h_ij(r) - c_ij(r) + b_ij(r) right), where beta = 1k_BT. ","category":"page"},{"location":"Theory.html#Fourier-Transforms","page":"Theory","title":"Fourier Transforms","text":"","category":"section"},{"location":"Theory.html#Thermodynamic-properties","page":"Theory","title":"Thermodynamic properties","text":"","category":"section"},{"location":"FromPython.html#Calling-from-Python","page":"From Python","title":"Calling from Python","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"Using OrnsteinZernike from Python is straighforward","category":"page"},{"location":"FromPython.html#Installing","page":"From Python","title":"Installing","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"First, install juliacall through the pip package manager, with","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"pip install juliacall","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"This package allows one to call julia from python ","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"In Python (only versions geq 3 are supported), run:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"from juliacall import Main as jl","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"which will install the latest stable version of Julia the first time it is called. Now install OrnsteinZernike.jl, with","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"\njl.Pkg.add(\"OrnsteinZernike\")","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"To import this package in order to use it we need to run:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"jl.seval(\"using OrnsteinZernike\")","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"The jl.seval function let's us evaluate any julia code from within Python.","category":"page"},{"location":"FromPython.html#Usage","page":"From Python","title":"Usage","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"We can now use OrnsteinZernike.jl in Python:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"dims = 3\nkBT = 1.0\nrho = 0.5\npotential = jl.SingleComponentHardSpheres()\nsystem = jl.SimpleLiquid(dims, rho, kBT, potential)\nclosure = jl.PercusYevick()\nsol = jl.solve(system, closure)\n\nimport matplotlib.pyplot as plt\n\nplt.plot(sol.r, sol.gr)\nplt.xlim(0, 5)\nplt.show()","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"(Image: image)","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"See the documentation of juliacall for more information on how to call Julia from Python.","category":"page"},{"location":"Potentials.html#Interaction-Potentials","page":"Interaction Potentials","title":"Interaction Potentials","text":"","category":"section"},{"location":"Potentials.html","page":"Interaction Potentials","title":"Interaction Potentials","text":"This package defines several potentials that can be used out of the box. It is straightforward to implement your own potential, see Defining your own potentials. To evaluate the potential, call OrnsteinZernike.evaluate_potential(potential, r). For example:","category":"page"},{"location":"Potentials.html","page":"Interaction Potentials","title":"Interaction Potentials","text":"using OrnsteinZernike, Plots\nr = 0.9:0.01:4.0\npotential = SingleComponentLennardJones(1.0, 1.0)\nu = OrnsteinZernike.evaluate_potential(potential, r)\nplot(r, u, xlabel=\"r\", ylabel=\"u(r)\", ylims=(-1,1), label=nothing)","category":"page"},{"location":"Potentials.html#Implemented-interaction-potentials","page":"Interaction Potentials","title":"Implemented interaction potentials","text":"","category":"section"},{"location":"Potentials.html","page":"Interaction Potentials","title":"Interaction Potentials","text":"Below is a list of implemented closures. We use the notation shown in the Theory section.","category":"page"},{"location":"Potentials.html","page":"Interaction Potentials","title":"Interaction Potentials","text":"Modules = [OrnsteinZernike]\nFilter = t -> (typeof(t) === DataType || typeof(t) === UnionAll) && t <: OrnsteinZernike.Potential\nPrivate = false","category":"page"},{"location":"Potentials.html#OrnsteinZernike.MultiComponentHardSpheres","page":"Interaction Potentials","title":"OrnsteinZernike.MultiComponentHardSpheres","text":"MultiComponentHardSpheres\n\nImplements the hard-sphere pair interaction u_ij(r) = infty for r  D_ij and u_ij(r) = 0 for r  D_ij.\n\nExpects a vector D_i of diameters for each of the species. An additive mixing rule is used left(D_ij = (D_i+D_j)2right).\n\nExample:\n\nclosure = MultiComponentHardSpheres([0.8, 0.9, 1.0])\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.SingleComponentHardSpheres","page":"Interaction Potentials","title":"OrnsteinZernike.SingleComponentHardSpheres","text":"SingleComponentHardSpheres\n\nImplements the hard-sphere pair interaction $ u(r) = \\infty$ for r  1 and u(r) = 0 for r  1.\n\nExample:\n\nclosure = SingleComponentHardSpheres()\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.SingleComponentLennardJones","page":"Interaction Potentials","title":"OrnsteinZernike.SingleComponentLennardJones","text":"SingleComponentLennardJones\n\nImplements the Lennard-Jones pair interaction u(r) = 4epsilon (sigmar)^12 - (sigmar)^6.\n\nExpects values ϵ and σ, which respecively are the strength of the potential and particle size. \n\nExample:\n\nclosure = SingleComponentLennardJones(1.0, 2.0)\n\n\n\n\n\n","category":"type"},{"location":"GeneralWorkflow.html#General-Workflow","page":"General Workflow","title":"General Workflow","text":"","category":"section"},{"location":"GeneralWorkflow.html","page":"General Workflow","title":"General Workflow","text":"In general, solving an Ornstein-Zernike equation requires the definition of following items. The linked pages describe these in more details. ","category":"page"},{"location":"GeneralWorkflow.html","page":"General Workflow","title":"General Workflow","text":"The interaction potential: Interaction Potentials\nThe system parameters: density, temperature and dimensionality: Systems \nThe closure relation: Closures\nThe solver: Solvers","category":"page"},{"location":"GeneralWorkflow.html","page":"General Workflow","title":"General Workflow","text":"Once these have been defined, solve can be called to solve the system at hand. ","category":"page"},{"location":"Solvers.html#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"Having defined a SimpleLiquid and a Closure, one should choose a method by which to solve the equations. The implemented methods are Exact, FourierIteration, NgIteration. ","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"All solvers in some way, need to define a grid on which to solve the equations. This is done using the keyword arguments for M and dr, which represent respectively the number of grid points, and the spacing between them. Some solvers have additional settings, such as a tolerance. Using powers of 2 for M typically give the best performance (for 3D systems).","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"For the implemented cases, Exact solves the system exactly, or throws an error if the method is not implemented. ","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"Exact","category":"page"},{"location":"Solvers.html#OrnsteinZernike.Exact","page":"Solvers","title":"OrnsteinZernike.Exact","text":"Exact <: Method\n\nSolves the system exactly. This is only implemented for specific systems.\n\nRight now, the implemented exact methods are\n\nthree-dimensional single-component system of hard spheres with the Percus Yevick closure\nthree-dimensional multi-component system of hard spheres with the Percus Yevick closure\n\nConstruct using \n\nExact(;  M=2^10, dr = sqrt(π/(M+1))/(2π))\n\nHere, M is the number of points that the exact solution is evaluated on, and dr is the grid spacing. These are used to perform Fourier transformations.\n\nExamples\n\nmethod = Exact()\n\nmethod = Exact(M=1000)\n\nmethod = Exact(M=1000, dr=0.01)\n\n\n\n\n\n","category":"type"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"The methods FourierIteration and NgIteration both use recursive iteration to find improved estimates of the solution using Fourier Transforms. NgIteration uses a scheme to accelerate convergence, see Ref. [1]. ","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"FourierIteration\nNgIteration","category":"page"},{"location":"Solvers.html#OrnsteinZernike.FourierIteration","page":"Solvers","title":"OrnsteinZernike.FourierIteration","text":"FourierIteration <: Method\n\nSolves the system by recursive iteration in Fourier Space. Essentially, the algorithm is:\n\nguess an initial γ(r)\nfind c(r) using the closure relation\nfourier transform to get ĉ(k)\nfind γ(k) using the OZ-eq in k-space\ncompute γ(r) with a inverse fourier transform\ncompare with previous value, if not converged go to 2.\n\nOptionally, a mixing rule is used to mix the new and previous iteration of c(r) in step 2. \n\nArguments:\n\nM::Int: number of points discretize the solution on \ndr::Float64: grid spacing in real space\nmixing_parameter::Float64: mixing parameter for iteration mixing. A value of 1 is no mixing. Must be between 0 and 1. \nmax_iterations::Int64: maximal number of iterations \ntolerance::Float64: tolerance to be reached\nverbose::Bool: whether or not to print convergence information\n\nDefault: FourierIteration(; mixing_parameter=0.5, max_iterations=10^5, tolerance=10^-6, verbose=true, M=2^10, dr=sqrt(π/(M+1))/(2π))\n\n\n\n\n\n","category":"type"},{"location":"Solvers.html#OrnsteinZernike.NgIteration","page":"Solvers","title":"OrnsteinZernike.NgIteration","text":"NgIteration <: Method\n\nSolves the system by recursive iteration in Fourier Space, and uses the Ng acceleration method. Essentially, the algorithm is:\n\nguess an initial γ(r)\nfind c(r) using the closure relation\nfourier transform to get ĉ(k)\nfind γ(k) using the OZ-eq in k-space\ncompute γ(r) with a inverse fourier transform\nuse Ng's method to provide a next guess for γ\ncompare with previous value, if not converged go to 2.\n\nArguments:\n\nM::Int: number of points discretize the solution on \ndr::Float64: grid spacing in real space\nN_stages::Int: Number of previous values to take into account for step 6. A higher number should lead to faster convergence, yet more computation time per iteration.\nmax_iterations::Int64: maximal number of iterations \ntolerance::Float64: tolerance to be reached\nverbose::Bool: whether or not to print convergence information\n\nDefault: NgIteration(; N_stages=3, max_iterations=10^3, tolerance=10^-6, verbose=true, M=2^10, dr=sqrt(π/(M+1))/(2π))\n\nReferences: Ng, K. C. (1974). Hypernetted chain solutions for the classical one‐component plasma up to Γ= 7000. The Journal of Chemical Physics, 61(7), 2680-2689.\n\n\n\n\n\n","category":"type"},{"location":"ExtendingPotentials.html#Defining-your-own-potentials","page":"Defining your own potentials","title":"Defining your own potentials","text":"","category":"section"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"Creating your own potentials type is very easy. It takes two steps. First, the type itself must be created, and secondly, function that evaluates the potentials must be overloaded. ","category":"page"},{"location":"ExtendingPotentials.html#Example","page":"Defining your own potentials","title":"Example","text":"","category":"section"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"We want to implement the interaction potential  u(r) = epsilon (fracsigmar)^6","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"To do this, first we define the type. Note that the new potential must be made a subtype of OrnsteinZernike.Potential","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"using OrnsteinZernike\n\nimport OrnsteinZernike.Potential\nstruct MyPot <: Potential \n    epsilon::Float64\n    sigma::Float64\nend","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"Now we can define how this potential should be evaluated. We must overload   evaluate_potential(potential::Potential, r::Number)","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"import OrnsteinZernike.evaluate_potential\nfunction OrnsteinZernike.evaluate_potential(pot::MyPot, r::Number)\n    return pot.epsilon * (pot.sigma / r) ^ 6\nend","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"Now we can use the potential as any other ","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"ϵ = 1.0\nσ = 1.0\npotential = MyPot(ϵ, σ)\ndims = 3 # we consider a 3D system\nρ = 0.5 # number density\nkBT = 1.0 # thermal energy\nsystem = SimpleLiquid(dims, ρ, kBT, potential)\nclosure = HypernettedChain()\nsol = solve(system, closure)\nusing Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\")","category":"page"},{"location":"ExtendingPotentials.html#Mixtures","page":"Defining your own potentials","title":"Mixtures","text":"","category":"section"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"In the case of multicomponent systems, instead of a number the evaluate_potential should return a StaticMatrix from the StaticArrays package containing either values for u_ij. ","category":"page"},{"location":"ExtendingPotentials.html#Example-2","page":"Defining your own potentials","title":"Example","text":"","category":"section"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"Suppose we want to implement the same potential for the multicomponent case: u_ij(r) = epsilon_ij (fracsigma_ijr_ij)^6","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"using OrnsteinZernike, StaticArrays\n\nimport OrnsteinZernike.Potential\nstruct MyPot2{Nspecies} <: Potential \n    epsilon::Matrix{Float64}\n    sigma::Matrix{Float64}\nend","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"Here we have made the type parametric with respect to the number of species","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"import OrnsteinZernike.evaluate_potential\nfunction OrnsteinZernike.evaluate_potential(pot::MyPot2{Nspecies}, r::Number) where Nspecies\n    # we can construct a mutable sized matrix first\n    out = MMatrix{Nspecies, Nspecies, Float64, Nspecies*Nspecies}(undef) \n    for species2 = 1:Nspecies\n        for species1 = 1:Nspecies\n            out[species1, species2] = pot.epsilon[species1, species2] * (pot.sigma[species1, species2] / r) ^ 6\n        end\n    end\n    # and convert it to an immutable variant\n    return SMatrix(out) \nend","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"and now we can use it:","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"using OrnsteinZernike, StaticArrays # hide\n\nimport OrnsteinZernike.Potential # hide\nstruct MyPot2{Nspecies} <: Potential  # hide\n    epsilon::Matrix{Float64} # hide\n    sigma::Matrix{Float64} # hide\nend # hide\n\nimport OrnsteinZernike.evaluate_potential # hide\nfunction OrnsteinZernike.evaluate_potential(pot::MyPot2{Nspecies}, r::Number) where Nspecies # hide\n    # we can construct a mutable sized matrix first # hide\n    out = MMatrix{Nspecies, Nspecies, Float64, Nspecies*Nspecies}(undef)  # hide\n    for species2 = 1:Nspecies # hide\n        for species1 = 1:Nspecies # hide\n            out[species1, species2] = pot.epsilon[species1, species2] * (pot.sigma[species1, species2] / r) ^ 6 # hide\n        end # hide\n    end # hide\n    # and convert it to an immutable variant # hide\n    return SMatrix(out)  # hide\nend # hide\nϵ = [1.0 2.0; 0.4 0.9]\nσ = [1.0 1.0; 1.0 0.8]\ndims = 3 # we consider a 3D system\npotential = MyPot2{2}(ϵ, σ)\nρ = [0.25, 0.25] # number density\nkBT = 1.0 # thermal energy\nsystem = SimpleLiquid(dims, ρ, kBT, potential)\nclosure = HypernettedChain()\nsol = solve(system, closure)\nusing Plots\nplot(sol.r, sol.gr[:, 1, 1], xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", label=\"g11(r)\")\nplot!(sol.r, sol.gr[:, 1, 2], xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", label=\"g12(r)\")\nplot!(sol.r, sol.gr[:, 2, 2], xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", label=\"g22(r)\")","category":"page"},{"location":"Systems.html#Systems","page":"Systems","title":"Systems","text":"","category":"section"},{"location":"Systems.html","page":"Systems","title":"Systems","text":"A System object specifies what type of system needs to be solved. This includes the dimensionality, density and temperature, as well as the interaction potential as defined according to the previous page. Right now, this package exports only one type of System: SimpleLiquid. ","category":"page"},{"location":"Systems.html#SimpleLiquid","page":"Systems","title":"SimpleLiquid","text":"","category":"section"},{"location":"Systems.html","page":"Systems","title":"Systems","text":"The SimpleLiquid system assumes that the potentials involved are rotationally symmetric, and therefore depends only on center-to-center distance. Additionally, it assumes that there is no present external field. It can be used both in the single component case, as well as for multi-component systems (mixtures).","category":"page"},{"location":"Systems.html","page":"Systems","title":"Systems","text":"For single component systems, the density ρ is assumed to be a scalar, while for multicomponent systems, it should be a vector. Internally, the package converts it into a diagonal matrix.","category":"page"},{"location":"Systems.html","page":"Systems","title":"Systems","text":"Example 1: a 2-dimensional Lennard-Jones system","category":"page"},{"location":"Systems.html","page":"Systems","title":"Systems","text":"using OrnsteinZernike \npotential = SingleComponentLennardJones(1.0, 1.0)\nkBT = 1.0\nρ = 0.5\ndims = 2\nsystem = SimpleLiquid(dims, ρ, kBT, potential)","category":"page"},{"location":"Systems.html","page":"Systems","title":"Systems","text":"Example 1: a 3-dimensional 10-component hard-sphere system","category":"page"},{"location":"Systems.html","page":"Systems","title":"Systems","text":"using OrnsteinZernike # hide \nD = 0.1:0.1:1.0\npotential = MultiComponentHardSpheres(D)\nkBT = 1.0\nρ = ones(10)/10\ndims = 3\nsystem = SimpleLiquid(dims, ρ, kBT, potential)","category":"page"},{"location":"Closures.html#Closures","page":"Closures","title":"Closures","text":"","category":"section"},{"location":"Closures.html","page":"Closures","title":"Closures","text":"This package defines several closure relations that can be used out of the box. It is straightforward to implement your own closure, see Defining your own closure. ","category":"page"},{"location":"Closures.html","page":"Closures","title":"Closures","text":"using OrnsteinZernike, Plots\nclosure = PercusYevick()","category":"page"},{"location":"Closures.html#Implemented-Closures","page":"Closures","title":"Implemented Closures","text":"","category":"section"},{"location":"Closures.html","page":"Closures","title":"Closures","text":"Below is a list of implemented closures. We use the notation shown in the Theory section.","category":"page"},{"location":"Closures.html","page":"Closures","title":"Closures","text":"Modules = [OrnsteinZernike]\nFilter = t -> ((typeof(t) === DataType || typeof(t) === UnionAll) && t <: OrnsteinZernike.Closure)\nPrivate = false","category":"page"},{"location":"Closures.html#OrnsteinZernike.HypernettedChain","page":"Closures","title":"OrnsteinZernike.HypernettedChain","text":"HypernettedChain\n\nImplements the Hypernetted Chain closure c(r) = (f(r)+1)exp(gamma(r)) - gamma(r) - 1, or equivalently b(r) = 0.\n\nExample:\n\nclosure = HypernettedChain()\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.MeanSphericalApproximation","page":"Closures","title":"OrnsteinZernike.MeanSphericalApproximation","text":"MeanSphericalApproximation\n\nImplements the MSA closure c(r) = -beta u(r), or equivalently b(r) = ln(gamma(r) - beta u(r) + 1) - γ(r) +  beta u(r).\n\nExample:\n\nclosure = MeanSphericalApproximation()\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.PercusYevick","page":"Closures","title":"OrnsteinZernike.PercusYevick","text":"PercusYevick\n\nImplements the Percus-Yevick closure c(r) = f(r)(1+gamma(r)), or equivalently b(r) = ln(1 + gamma(r)) - γ(r).\n\nExample:\n\nclosure = PercusYevick()\n\n\n\n\n\n","category":"type"},{"location":"SingleCompLJ.html#First-steps","page":"First steps","title":"First steps","text":"","category":"section"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"In order to solve an Ornstein-Zernike equation, there are a number of things that need to be specified. ","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"The interaction potential, \nThe system parameters: density, temperature and dimensionality\nThe closure relation\nThe solver","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"Let's start with a very simple example: a three-dimensional 1-component Lennard-Jones system. For this potential, we can make use of the built-in potential ","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"using OrnsteinZernike\nϵ = 1.0\nσ = 1.0\npotential = SingleComponentLennardJones(ϵ, σ)","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"Now that we have the potential, we define the system","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"dims = 3 # we consider a 3D system\nρ = 0.01 # number density\nkBT = 1.0 # thermal energy\nsystem = SimpleLiquid(dims, ρ, kBT, potential)","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"The SimpleLiquid object is meant to be used when dealing with systems that have spherically symmetric interaction potentials and no external fields. ","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"The third step is to define a closure relation. For now, let's stick to the simple hypernetted chain closure","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"closure = HypernettedChain()","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"We can now solve the system. ","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"sol = solve(system, closure)","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"Note that we have not specified the method by which we do so. In this case, a simple default method is chosen that works well in most cases.","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"The sol object contains fields for the radial distribution function gr, direct correlation function (in real and Fourier space) cr and ck, the static structure factor Sk, and arrays for r and k. For example, we can plot the radial distribution function as follows:","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"using Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\")","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"Full code:","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"using OrnsteinZernike\nϵ = 1.0\nσ = 1.0\npotential = SingleComponentLennardJones(ϵ, σ)\ndims = 3 # we consider a 3D system\nρ = 0.01 # number density\nkBT = 1.0 # thermal energy\nsystem = SimpleLiquid(dims, ρ, kBT, potential)\nclosure = HypernettedChain()\nsol = solve(system, closure)\nusing Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\")","category":"page"},{"location":"API.html#The-OrnsteinZernike-Module","page":"API","title":"The OrnsteinZernike Module","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"OrnsteinZernike","category":"page"},{"location":"API.html#OrnsteinZernike","page":"API","title":"OrnsteinZernike","text":"A generic solver package for Ornstein-Zernike equations from liquid state theory\n\n\n\n\n\n","category":"module"},{"location":"API.html#Module-Index","page":"API","title":"Module Index","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [OrnsteinZernike]\nOrder   = [:constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"API.html#Detailed-API","page":"API","title":"Detailed API","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [OrnsteinZernike]\nOrder   = [:constant, :type, :function, :macro]\nFilter = t -> (!(typeof(t) === DataType || typeof(t) === UnionAll) || (!(t <: OrnsteinZernike.Closure) && !(t <: OrnsteinZernike.Potential) && !(t <: OrnsteinZernike.Method)))\nPrivate = false","category":"page"},{"location":"API.html#OrnsteinZernike.OZSolution","page":"API","title":"OrnsteinZernike.OZSolution","text":"OZSolution\n\nHolds the solution of an Ornstein Zernike problem. \n\nFields:\n\nr: vector of distances\nk: vector of wave numbers\ngr: radial distribution function    \nSk: static structure factor\nck: direct correlation function in k space\ncr: direct correlation function in real space\n\nif the system was a single-component system, gr, Sk, ck and cr are vectors.  If instead the system was a multicomponent one, they are three dimensional vectors,  where the first dimension contains the values along r, and the second and third dimension contain the data for the species.\n\n\n\n\n\n","category":"type"},{"location":"API.html#OrnsteinZernike.SimpleLiquid","page":"API","title":"OrnsteinZernike.SimpleLiquid","text":"SimpleLiquid{dims, ...} <: System\n\nHolds information about a homogeneous, isotropic system with radially symmetric pair interactions. dims is the dimensionality.\n\nConstruct using\n\nSimpleLiquid(dims, ρ, kBT, potential)\n\nFields:\n\nρ: number density, must be either a Number in case of a single component system, or a Vector in case of a mixture. In the latter case, each element contains the number density of the respective component.\nkBT: thermal energy\npotential::Potential: the interaction potential.  \n\nExamples:\n\nρ = 0.5; kBT = 1.1; dims = 3\npot = SingleComponentHardSpheres()\nsystem = SimpleLiquid(dims, ρ, kBT, pot)\n\nρ = [0.5, 0.1]; kBT = 5.2; dims = 3\npot = MultiComponentHardSpheres([1.0, 0.8])\nsystem = SimpleLiquid(dims, ρ, kBT, pot)\n\n\n\n\n\n","category":"type"},{"location":"API.html#OrnsteinZernike.compute_compressibility-Union{Tuple{P}, Tuple{T2}, Tuple{T1}, Tuple{dims}, Tuple{OZSolution, SimpleLiquid{dims, 1, T1, T2, P}}} where {dims, T1, T2, P}","page":"API","title":"OrnsteinZernike.compute_compressibility","text":"compute_compressibility(sol::OZSolution, system::SimpleLiquid)\n\nComputes the isothermal compressibility χ of the system\n\nuses the formula 1/χ = 1 - ρ ĉ(k=0) for single component systems and 1/χ = 1 - ρ Σᵢⱼ xᵢxⱼ ĉᵢⱼ(k=0) for mixtures. \n\n\n\n\n\n","category":"method"},{"location":"API.html#OrnsteinZernike.compute_excess_energy-Union{Tuple{P}, Tuple{T2}, Tuple{T1}, Tuple{OZSolution, SimpleLiquid{3, 1, T1, T2, P}}} where {T1, T2, P}","page":"API","title":"OrnsteinZernike.compute_excess_energy","text":"compute_excess_energy(sol::OZSolution, system::SimpleLiquid)\n\nComputes the excess energy per particle Eₓ, such that E = (dims/2kBT + Eₓ)N.\n\nuses the formula Eₓ = 1/2 ρ ∫dr g(r) u(r) for single component systems and Eₓ = 1/2 ρ Σᵢⱼ xᵢxⱼ ∫dr gᵢⱼ(r) uᵢⱼ(r) for mixtures. Here x is the concentration fraction ρᵢ/sum(ρ).\n\n\n\n\n\n","category":"method"},{"location":"API.html#OrnsteinZernike.compute_virial_pressure-Union{Tuple{P}, Tuple{T2}, Tuple{T1}, Tuple{OZSolution, SimpleLiquid{3, 1, T1, T2, P}}} where {T1, T2, P}","page":"API","title":"OrnsteinZernike.compute_virial_pressure","text":"compute_virial_pressure(sol::OZSolution, system::SimpleLiquid)\n\nComputes the pressure via the virial route\n\nuses the formula p = kBTρ - 1/6 ρ^2 ∫dr g(r) u'(r) for single component systems and p =  kBT Σᵢρᵢ - 1/6 Σᵢ ρᵢρⱼ ∫dr gᵢⱼ(r) u'ᵢⱼ(r) for mixtures.\n\n\n\n\n\n","category":"method"},{"location":"API.html#OrnsteinZernike.solve","page":"API","title":"OrnsteinZernike.solve","text":"solve(system::SimpleLiquid, closure::Closure, method::Method)\n\nSolves the system system using the closure closure with method method.\n\nsolve(system::SimpleLiquid, closure::Closure)\n\nSolves the system system using the closure closure with the default method NgIteration().\n\n\n\n\n\n","category":"function"},{"location":"HardSphereMixture.html#Hard-sphere-mixture","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"","category":"section"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"The previous example showed the case of a 1-component system. Let's instead look at mixtures here. Consider a 3:1 mixture of hard spheres with sizes 0.5 and 1.0. We solve the system with the same three steps as before.","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"First, we define the potential. Here, we must use MultiComponentHardSpheres, which takes a vector containing the diameters of each species.","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"using OrnsteinZernike\nD = [0.5, 1.0]\npotential = MultiComponentHardSpheres(D)","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"Secondly, we define the system. In this example, the total number density is rho = 16. For mixtures, the system expects a vector of individual densities. Those are computed by multiplying the total density with the concentration fraction vector.","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"ρ_total = 1.6\nρ = ρ_total*[0.75, 0.25] ## it is a 3:1 system\ndims = 3 # we consider a 3D system\nkBT = 1.0 # thermal energy\nsystem = SimpleLiquid(dims, ρ, kBT, potential)","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"Thirdly, we define the closure","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"closure = PercusYevick()","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"And now we solve the system. ","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"sol = solve(system, closure)","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"For mixtures, the fields sol.gr, sol.cr, sol.ck, and sol.Sk are now three dimensional arrays with shape (Nr, Ns, Ns). For example, g_12(r_6) is stored in sol.gr[6,1,2].","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"We just solved the system using the default iterative solver introduced by Ng NgIteration. However, in this specific case, an exact solution is implemented. To use this, we specify the method Exact().","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"method = Exact()\nsol_exact = solve(system, closure, method)","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"Let's plot the resulting g(r). ","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"using Plots\nplot(sol.r, sol.gr[:, 1, 1], xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", lw=4, label=\"g11(r) iterative\")\nplot!(sol.r, sol.gr[:, 1, 2], xlabel=\"r\", ylabel=\"g(r)\", lw=4, label=\"g12(r) iterative\")\nplot!(sol.r, sol.gr[:, 2, 2], xlabel=\"r\", ylabel=\"g(r)\", lw=4, label=\"g22(r) iterative\")\nplot!(sol_exact.r, sol_exact.gr[:, 1, 1], lw=2, c=:black, label=\"exact\")\nplot!(sol_exact.r, sol_exact.gr[:, 1, 2], lw=2, c=:black, label=nothing)\nplot!(sol_exact.r, sol_exact.gr[:, 2, 2], lw=2, c=:black, label=nothing)","category":"page"},{"location":"index.html#OrnsteinZernike.jl","page":"Index","title":"OrnsteinZernike.jl","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"OrnsteinZernike.jl provides generic solvers for Ornstein-Zernike equations from liquid state theory.","category":"page"},{"location":"index.html#Installation","page":"Index","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"To install the package run ","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"import Pkg\nPkg.add(\"https://github.com/IlianPihlajamaa/OrnsteinZernike.jl\")","category":"page"}]
}
