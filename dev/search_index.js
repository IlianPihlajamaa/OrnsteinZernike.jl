var documenterSearchIndex = {"docs":
[{"location":"anotherPage.html#The-OrnsteinZernike-Module","page":"An other page","title":"The OrnsteinZernike Module","text":"","category":"section"},{"location":"anotherPage.html","page":"An other page","title":"An other page","text":"OrnsteinZernike","category":"page"},{"location":"anotherPage.html#Module-Index","page":"An other page","title":"Module Index","text":"","category":"section"},{"location":"anotherPage.html","page":"An other page","title":"An other page","text":"Modules = [OrnsteinZernike]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"anotherPage.html#Detailed-API","page":"An other page","title":"Detailed API","text":"","category":"section"},{"location":"anotherPage.html","page":"An other page","title":"An other page","text":"Modules = [OrnsteinZernike]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"anotherPage.html#OrnsteinZernike.Closure","page":"An other page","title":"OrnsteinZernike.Closure","text":"Closure\n\nAbstract closure type\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.DensityRamp","page":"An other page","title":"OrnsteinZernike.DensityRamp","text":"DensityRamp <: Method\n\nSolves the system by iteratively solving systems of increasing density, using the previous solution as initial guess at a higher density. This may help deal with convergence issues\n\nArguments\n\nmethod: method by which to solve the system for individual densities.\ndensities: densities to consider. Must be a vector of increasing values.\nverbose: whether to print information.\n\nExample: DensityRamp(NgIteration(), [0.1, 0.3, 0.4]; verbose=false)\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.Exact","page":"An other page","title":"OrnsteinZernike.Exact","text":"Exact <: Method\n\nSolves the system exactly. This is only implemented for specific systems.\n\nConstruct using Exact(;  M=2^10, dr = sqrt(π/(M+1))/(2π)) Here, M is the number of points that the exact solution is evaluated on, and dr is the grid spacing. These are used to perform fourier transformations.\n\nExamples\n\nmethod = Exact() method = Exact(M=1000) method = Exact(M=1000, dr=0.01)\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.FourierIteration","page":"An other page","title":"OrnsteinZernike.FourierIteration","text":"FourierIteration <: Method\n\nSolves the system by recursive iteration in Fourier Space. Essentially, the algorithm is:\n\nguess an initial γ(r)\nfind c(r) using the closure relation\nfourier transform to get ĉ(k)\nfind γ(k) using the OZ-eq in k-space\ncompute γ(r) with a inverse fourier transform\ncompare with previous value, if not converged go to 2.\n\nOptionally, a mixing rule is used to mix the new and previous iteration of c(r) in step 2. \n\nArguments:\n\nM::Int: number of points discretize the solution on \ndr::Float64: grid spacing in real space\nmixing_parameter::Float64: mixing parameter for iteration mixing. A value of 1 is no mixing. Must be between 0 and 1. \nmax_iterations::Int64: maximal number of iterations \ntolerance::Float64: tolerance to be reached\nverbose::Bool: whether or not to print convergence information\n\ndefault: FourierIteration(; mixingparameter=0.5, maxiterations=10^5, tolerance=10^-6, verbose=true, M=2^10, dr=sqrt(π/(M+1))/(2π))\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.HypernettedChain","page":"An other page","title":"OrnsteinZernike.HypernettedChain","text":"Hypernetted Chain Closure\n\nImplements the closure c(r) = (f(r)+1)*exp(γ(r)) - γ(r) - 1, or equivalently b(r) = 0.\n\nExample: closure = HypernettedChain()\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.MeanSpherical","page":"An other page","title":"OrnsteinZernike.MeanSpherical","text":"Mean Spherical Closure\n\nImplements the closure c(r) = -βu(r), or equivalently b(r) = ln(γ(r) - βu(r) + 1) - γ(r) +  βu(r).\n\nExample: closure = MeanSpherical()\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.Method","page":"An other page","title":"OrnsteinZernike.Method","text":"Method\n\nAbstract method type\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.MultiComponentHardSpheres","page":"An other page","title":"OrnsteinZernike.MultiComponentHardSpheres","text":"MultiComponentHardSpheres\n\nImplements the hard-sphere pair interaction uᵢⱼ(r) = inf r<Dᵢⱼ and uᵢⱼ(r) = 0 r>Dᵢⱼ for a multicomponent system.\n\nExpects a vector Dᵢ of diameters for each of the species. An additive mixing rule is used (Dᵢⱼ = (Dᵢ+Dⱼ)/2).\n\nExample: closure = MultiComponentHardSpheres([0.8, 0.9, 1.0])\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.NgIteration","page":"An other page","title":"OrnsteinZernike.NgIteration","text":"NgIteration <: Method\n\nSolves the system by recursive iteration in Fourier Space, and uses the Ng acceleration method. Essentially, the algorithm is:\n\nguess an initial γ(r)\nfind c(r) using the closure relation\nfourier transform to get ĉ(k)\nfind γ(k) using the OZ-eq in k-space\ncompute γ(r) with a inverse fourier transform\nuse Ng's method to provide a next guess for γ\ncompare with previous value, if not converged go to 2.\n\nArguments:\n\nM::Int: number of points discretize the solution on \ndr::Float64: grid spacing in real space\nN_stages::Int: Number of previous values to take into account for step 6. A higher number should lead to faster convergence, yet more computation time per iteration.\nmax_iterations::Int64: maximal number of iterations \ntolerance::Float64: tolerance to be reached\nverbose::Bool: whether or not to print convergence information\n\ndefault: NgIteration(; Nstages=3, maxiterations=10^3, tolerance=10^-6, verbose=true, M=2^10, dr=sqrt(π/(M+1))/(2π))\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.OZSolution","page":"An other page","title":"OrnsteinZernike.OZSolution","text":"OZSolution\n\nHolds the solution of an Ornstein Zernike problem. \n\nFields:\n\nr: vector of distances\nk: vector of wave numbers\ngr: radial distribution function    \nSk: static structure factor\nck: direct correlation function in k space\ncr: direct correlation function in real space\n\nif the system was a single-component system, gr, Sk, ck and cr are vectors.  If instead the system was a multicomponent one, they are three dimensional vectors,  where the first dimension contains the values along r, and the second and third dimension contain the data for the species.\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.PercusYevick","page":"An other page","title":"OrnsteinZernike.PercusYevick","text":"Percus Yevick Closure\n\nImplements the closure c(r) = f(r)*(1+γ(r)), or equivalently b(r) = ln(1 + γ(r)) - γ(r).\n\nExample: closure = PercusYevick()\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.Potential","page":"An other page","title":"OrnsteinZernike.Potential","text":"Potential\n\nAbstract potential type\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.SimpleLiquid","page":"An other page","title":"OrnsteinZernike.SimpleLiquid","text":"SimpleLiquid{dims, ...} <: System\n\nHolds information about a homogeneous, isotropic system with radially symmetric pair interactions. dims is the dimensionality.\n\nConstruct using\n\nSimpleLiquid(dims, ρ, kBT, potential)\n\nFields:\n\nρ: number density, must be either a Number in case of a single component system, or a Vector in case of a mixture. In the latter case, each element contains the number density of the respective component.\nkBT: thermal energy\npotential::Potential: the interaction potential.  \n\nExamples:\n\nρ = 0.5; kBT = 1.1; dims = 3\npot = SingleComponentHardSpheres()\nsystem = SimpleLiquid(dims, ρ, kBT, pot)\n\nρ = [0.5, 0.1]; kBT = 5.2; dims = 3\npot = MultiComponentHardSpheres([1.0, 0.8])\nsystem = SimpleLiquid(dims, ρ, kBT, pot)\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.SingleComponentHardSpheres","page":"An other page","title":"OrnsteinZernike.SingleComponentHardSpheres","text":"SingleComponentHardSpheres\n\nImplements the hard-sphere pair interaction u(r) = inf r<1 and u(r) = 0 r>1.\n\nExample: closure = SingleComponentHardSpheres()\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.System","page":"An other page","title":"OrnsteinZernike.System","text":"System\n\nAbstract type for holding information about the system that needs to be solved\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#OrnsteinZernike.compute_compressibility-Union{Tuple{P}, Tuple{T2}, Tuple{T1}, Tuple{dims}, Tuple{OZSolution, SimpleLiquid{dims, 1, T1, T2, P}}} where {dims, T1, T2, P}","page":"An other page","title":"OrnsteinZernike.compute_compressibility","text":"compute_compressibility(sol::OZSolution, system::SimpleLiquid)\n\nComputes the isothermal compressibility χ of the system\n\nuses the formula 1/χ = 1 - ρ ĉ(k=0) for single component systems and 1/χ = 1 - ρ Σᵢⱼ xᵢxⱼ ĉᵢⱼ(k=0) for mixtures. \n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#OrnsteinZernike.compute_excess_energy-Union{Tuple{P}, Tuple{T2}, Tuple{T1}, Tuple{OZSolution, SimpleLiquid{3, 1, T1, T2, P}}} where {T1, T2, P}","page":"An other page","title":"OrnsteinZernike.compute_excess_energy","text":"compute_excess_energy(sol::OZSolution, system::SimpleLiquid)\n\nComputes the excess energy per particle Eₓ, such that E = (dims/2kBT + Eₓ)N.\n\nuses the formula Eₓ = 1/2 ρ ∫dr g(r) u(r) for single component systems and Eₓ = 1/2 ρ Σᵢⱼ xᵢxⱼ ∫dr gᵢⱼ(r) uᵢⱼ(r) for mixtures. Here x is the concentration fraction ρᵢ/sum(ρ).\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#OrnsteinZernike.compute_virial_pressure-Union{Tuple{P}, Tuple{T2}, Tuple{T1}, Tuple{OZSolution, SimpleLiquid{3, 1, T1, T2, P}}} where {T1, T2, P}","page":"An other page","title":"OrnsteinZernike.compute_virial_pressure","text":"compute_virial_pressure(sol::OZSolution, system::SimpleLiquid)\n\nComputes the pressure via the virial route\n\nuses the formula p = kBTρ - 1/6 ρ^2 ∫dr g(r) u'(r) for single component systems and p =  kBT Σᵢρᵢ - 1/6 Σᵢ ρᵢρⱼ ∫dr gᵢⱼ(r) u'ᵢⱼ(r) for mixtures.\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#OrnsteinZernike.find_mayer_f_function-Union{Tuple{P}, Tuple{T2}, Tuple{T1}, Tuple{species}, Tuple{dims}, Tuple{SimpleLiquid{dims, species, T1, T2, P}, Number, Number}} where {dims, species, T1, T2, P}","page":"An other page","title":"OrnsteinZernike.find_mayer_f_function","text":"exp(- beta * u) - 1.\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#OrnsteinZernike.fourier!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, FFTW.r2rFFTWPlan, Any}} where T","page":"An other page","title":"OrnsteinZernike.fourier!","text":"fourier!(F̂, F, plan, equation::OZEquation{3, T1, T2, T3}) where {T1, T2, T3}\n\ncomputes the three dimensional radial fourier transform of F = rf(r), returning F̂ = kf̂(k), where f̂ is the fourier transform of f. it uses the discrete sine tranform provided by the r2r function of FFTW internally.\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#OrnsteinZernike.inverse_fourier!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, FFTW.r2rFFTWPlan, Any}} where T","page":"An other page","title":"OrnsteinZernike.inverse_fourier!","text":"inverse_fourier!(F, F̂, plan, equation::OZEquation{3, T1, T2, T3}) where {T1, T2, T3}\n\ncomputes the three dimensional radial fourier transform of F̂ = kf̂(k), returning F = rf(r), where f̂ is the fourier transform of f. it uses the discrete sine tranform provided by the r2r function of FFTW internally.\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#OrnsteinZernike.solve","page":"An other page","title":"OrnsteinZernike.solve","text":"solve(system::SimpleLiquid, closure::Closure, method::Method)\n\nSolves the system system using the closure closure with method method.\n\nsolve(system::SimpleLiquid, closure::Closure)\n\nSolves the system system using the closure closure with the default method NgIteration().\n\n\n\n\n\n","category":"function"},{"location":"anotherPage.html#OrnsteinZernike.solve-Union{Tuple{P}, Tuple{T2}, Tuple{T1}, Tuple{dims}, Tuple{SimpleLiquid{dims, 1, T1, T2, P}, OrnsteinZernike.Closure, NgIteration}} where {dims, T1, T2, P}","page":"An other page","title":"OrnsteinZernike.solve","text":"\n\n\n\n","category":"method"},{"location":"anotherPage.html#OrnsteinZernike.solve-Union{Tuple{P}, Tuple{T2}, Tuple{T1}, Tuple{species}, Tuple{dims}, Tuple{SimpleLiquid{dims, species, T1, T2, P}, OrnsteinZernike.Closure, FourierIteration}} where {dims, species, T1, T2, P}","page":"An other page","title":"OrnsteinZernike.solve","text":"this is a function\n\n\n\n\n\n","category":"method"},{"location":"index.html#OrnsteinZernike.jl","page":"Index","title":"OrnsteinZernike.jl","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Documentation for OrnsteinZernike.jl","category":"page"}]
}
