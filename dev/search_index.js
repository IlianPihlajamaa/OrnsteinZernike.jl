var documenterSearchIndex = {"docs":
[{"location":"Accuracy.html#Accuracy","page":"Accuracy","title":"Accuracy","text":"","category":"section"},{"location":"Accuracy.html","page":"Accuracy","title":"Accuracy","text":"The discrete Fourier tranforms used by the FourierIteration, and NgIteration solvers to represent their continuous counterparts using first order accuracy in n dimensions and second order accuracy in three dimensions (with the trapezoidal rule). To obtain the latter accuracy, it is important that any discontinuities of the interaction potential lie on an exact multiple of dr. To test this, we can compute the pressure of a hard-sphere system, and compare to the exact value. Below, we compute the relative error for different values of the number of gridpoints M, and plot the result on a log-log-scale","category":"page"},{"location":"Accuracy.html","page":"Accuracy","title":"Accuracy","text":"using OrnsteinZernike,  Plots\n\n# Make sure the discontinuity is a multiple of dr\nRmax = 10.0\nM_array = 10 * round.(Int,  10 .^ (range(1,4,length=20)))\np = zeros(length(M_array))\nρ = 0.3\nkBT = 1.0\ndims = 3 \npot = HardSpheres(1.0)\nsystem = SimpleLiquid(dims, ρ, kBT, pot)\n\nfor (i,M) in enumerate(M_array)\n    dr = Rmax/M\n    method = NgIteration(M=M, dr=dr, verbose=false)\n    sol = solve(system, PercusYevick(), method)\n    pressure = compute_virial_pressure(sol, system)\n    p[i] = pressure/ρ/kBT-1.0\n    println(\"The pressure = \", round(pressure, digits=8), \" with M = $(M) gridpoints.\")\nend","category":"page"},{"location":"Accuracy.html","page":"Accuracy","title":"Accuracy","text":"We can see that the method has well-behaved second order convergence, and that with M=10^4, we get almost 6 digits of relative accuracy.","category":"page"},{"location":"Accuracy.html","page":"Accuracy","title":"Accuracy","text":"η = ρ/6*π\np_exact = (1+2η+3η^2)/(1-η)^2-1.0\nscatter(M_array, abs.(p.-p_exact)./p_exact)\nplot!(ylabel=\"relative error\", xlabel=\"M\", xscale=:log, yscale=:log)","category":"page"},{"location":"HighDensities.html#Solving-at-high-densities","page":"Solving at high densities","title":"Solving at high densities","text":"","category":"section"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"Sometimes, especially when dealing with high densities, the solvers do not converge out-of-the-box. Typically, the easiest way to solve this is to initialize the iterative procedures with solutions of the same equation at a lower density. While this can be done by hand using the init keyword argument of the solve function, a convenient method DensityRamp is implemented to do this automatically. For example, consider a hard sphere system at ρ = 1.2.","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"using OrnsteinZernike\nρ = 1.2\nkBT = 1.0\ndims = 3\n\npot = HardSpheres(1.0)\nsystem = SimpleLiquid(dims, ρ, kBT, pot)\nclosure = PercusYevick()\nmethod = NgIteration()\nsol = solve(system, closure, method);","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"After iteration 0, the error is 114.96374587156.\nAfter iteration 10, the error is 246.47358557791.\nAfter iteration 20, the error is 48.60970316414.\n[...]\nAfter iteration 980, the error is 600.93302065646.\nAfter iteration 990, the error is 346.00914196416.\nAfter iteration 1000, the error is 78.17527233114.\nERROR: Recursive iteration did not converge within 1001 steps. Current error = 78.17527233113674.\n [1] error(s::String)\n   @ Base .\\error.jl:35\n[...]","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"To solve an issue like this, we can define DensityRamp method. This takes two arguments. The first is the actual method by which to solve the equations, which we leave as NgIteration() and the second is a list of densities to be evaluated before the target density.","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"densities = [0.7, 0.9, 1.0, 1.1]\nmethod2 = DensityRamp(method, densities)\nsol = @time solve(system, closure, method2);","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"Solving the system at ρ = 0.7.\n\nAfter iteration 0, the error is 3.7927462113.\nAfter iteration 10, the error is 0.02748002125.\nAfter iteration 20, the error is 2.459e-8.\nConverged after 25 iterations, the error is 8.0e-11.\n\nSolving the system at ρ = 0.9.\n\nAfter iteration 0, the error is 1.46229405321.\nAfter iteration 10, the error is 0.02624986205.\nAfter iteration 20, the error is 1.78285e-6.\nConverged after 29 iterations, the error is 3.0e-11.\n\nSolving the system at ρ = 1.0.\n\nAfter iteration 0, the error is 6.91022217054.\nAfter iteration 10, the error is 0.25666355675.\nAfter iteration 20, the error is 0.01233410847.\nAfter iteration 30, the error is 1.888465e-5.\nAfter iteration 40, the error is 1.94e-9.\nConverged after 44 iterations, the error is 8.0e-11.\n\nSolving the system at ρ = 1.1.\n\nAfter iteration 0, the error is 42.29810538999.\nAfter iteration 10, the error is 0.37566377791.\nAfter iteration 20, the error is 0.27554017425.\n[...].\nAfter iteration 70, the error is 1.555e-8.\nAfter iteration 80, the error is 5.2e-10.\nConverged after 84 iterations, the error is 5.0e-11.\n\nSolving the system at ρ = 1.2.\n\nAfter iteration 0, the error is 57.02991026895.\nAfter iteration 10, the error is 0.36390031646.\nAfter iteration 20, the error is 0.38501430163.\n[...]\nAfter iteration 110, the error is 2.706384e-5.\nAfter iteration 120, the error is 7.97e-7.\nAfter iteration 130, the error is 4.98e-9.\nConverged after 135 iterations, the error is 7.0e-11.\n  0.048063 seconds (1.86 k allocations: 1.330 MiB)","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"Let's plot and compare with the exact solution:","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"using OrnsteinZernike # hide\nρ = 1.2 # hide\nkBT = 1.0 # hide\ndims = 3 # hide\npot = HardSpheres(1.0) # hide\nsystem = SimpleLiquid(dims, ρ, kBT, pot) # hide\nclosure = PercusYevick() # hide\nmethod = NgIteration() # hide\ndensities = [0.7, 0.9, 1.0, 1.1] # hide\nmethod2 = DensityRamp(method, densities) # hide\nsol = solve(system, closure, method2); # hide\nusing Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", lw=4, label=\"iterative\")\n\nmethod3 = Exact()\nsol = solve(system, closure, method3);\nplot!(sol.r, sol.gr, lw=2, color=:black, label=\"exact\")","category":"page"},{"location":"HighDensities.html","page":"Solving at high densities","title":"Solving at high densities","text":"We can see that while the density is so high that g(r) shows a non-physical negative dip, it converged to the right mathematical solution. Note that this method will not always lead to convergence. For example, setting the density to ρ = 2.0 in this example, probably won't be correctly solved no matter how many intermediate densities are considered.","category":"page"},{"location":"ExtendingClosures.html#Defining-your-own-closure","page":"Defining your own closure","title":"Defining your own closure","text":"","category":"section"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"Creating your own closure type is very easy. It takes two steps. First, the type itself must be created, and secondly, one of the methods that evaluates the closure must be overloaded.","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"There are three options. One can overload either","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"bridge_function(closure, r, mayer_f, γ, u_long_range)\nclosure_c_from_gamma(closure, r, mayer_f, γ, u_long_range)\nclosure_cmulr_from_gammamulr(closure, r, mayer_f, γ, u_long_range)","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"Here, mayer_f is the Mayer-f function f(r) = exp(-beta u(r)) - 1, and u_long_range is the tail part of the potential, if the closure needs that. In practise, which of the three methods is overloaded can be arbitrary and depends on what is most convenient.","category":"page"},{"location":"ExtendingClosures.html#Example","page":"Defining your own closure","title":"Example","text":"","category":"section"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"Assume that we have forgotten that the HypernettedChain closure is already implemented, and we wanted to reimplement it. The hypernetted chain closure approximates c(r) approx (f(r)+1)exp(gamma(r)) - gamma(r) - 1, or equivalently b(r) approx 0.","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"First we define the type. Note that the new closure must be made a subtype of OrnsteinZernike.Closure","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"using OrnsteinZernike\n\nimport OrnsteinZernike.Closure\nstruct MyHNC <: Closure end","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"Now we can define how this closure should be evaluated. Here, we can for example either do","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"import OrnsteinZernike.bridge_function\nfunction OrnsteinZernike.bridge_function(::MyHNC, _, _, _, _)\n    return 0.0\nend","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"or","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"import OrnsteinZernike.closure_c_from_gamma\nfunction OrnsteinZernike.closure_c_from_gamma(::MyHNC, _, mayer_f, γ, _)\n    return (mayer_f + 1) * exp(γ) - γ - 1\nend","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"Now we can use the closure as any other ","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"ϵ = 1.0\nσ = 1.0\nn = 12\npotential = PowerLaw(ϵ, σ, n)\ndims = 3 \nρ = 0.6 \nkBT = 1.0\nsystem = SimpleLiquid(dims, ρ, kBT, potential)\nclosure = MyHNC()\nsol = solve(system, closure)\nusing Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\")","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"which can be compared to that of First steps.","category":"page"},{"location":"ExtendingClosures.html#Mixtures","page":"Defining your own closure","title":"Mixtures","text":"","category":"section"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"In the case of multicomponent systems, instead of a number the function that is overloaded should return a StaticMatrix containing either values for c_ij or b_ij. Since, in that case also the inputs are StaticMatrix, we can make use of Julia's broadcasting syntax to perform an closure elementwise. ","category":"page"},{"location":"ExtendingClosures.html","page":"Defining your own closure","title":"Defining your own closure","text":"import OrnsteinZernike.closure_c_from_gamma\nfunction OrnsteinZernike.closure_c_from_gamma(::MyHNC, _, mayer_f, γ, _)\n    return @. (mayer_f + 1) * exp(γ) - γ - 1 # note the @.\nend","category":"page"},{"location":"Theory.html#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In this section, we describe our conventions and notation.","category":"page"},{"location":"Theory.html#Single-component-systems","page":"Theory","title":"Single component systems","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"The Ornstein zernike equation  h(r) = c(r) + rho int dtextbfr c(textbfr)h(textbfr - textbfr)  links the pair correlation function g(r) = h(r)+1 to the number density rho and the direct correlation function c(r). In order to solve it, a second relation between h(r) and c(r) must be specified. This is called the closure relation. ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In practise, the closure relation typically takes the form c(r) = f(gamma(r) r u(r)), where u(r) is the interaciton potential and gamma(r) = h(r) - c(r) is the indirect correlation function. Sometimes, instead the closure is defined for the bridge function b(r), and the closure relation is then given by h(r) - 1 = expleft(-beta u(r) + h(r) - c(r) + b(r) right), where beta = 1k_BT. ","category":"page"},{"location":"Theory.html#Mixtures","page":"Theory","title":"Mixtures","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Everything above generalizes to the mixture case:","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"The Ornstein zernike equation ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"h_ij(r) = c_ij(r) + sum_l rho_l int dtextbfr c_il(textbfr)h_lj(textbfr - textbfr)","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"links the pair correlation function g_ij(r) = h_ij(r)+1 to the species specific number density rho_i and the direct correlation function c_ij(r). In order to solve it, a second relation between h_ij(r) and c_ij(r) must be specified. This is called the closure relation. ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"In practise, the closure relation typically takes the form c_ij(r) = f(gamma_ij(r) r u_ij(r)), where u_ij(r) is the interaciton potential and gamma_ij(r) = h_ij(r) - c_ij(r) is the indirect correlation function. Sometimes, instead the closure is defined for the bridge function b(r), and the closure relation is then given by h_ij(r) - 1 = expleft(-beta u_ij(r) + h_ij(r) - c_ij(r) + b_ij(r) right), where beta = 1k_BT. ","category":"page"},{"location":"Theory.html#Fourier-Transforms","page":"Theory","title":"Fourier Transforms","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"The ability to numerically solve the Ornstein-Zernike equation relies heavily on doing repeated Fourier Transforms. In arbitrary dimensions, these Fourier transforms can be written as Hankel transforms in the case that the argument is a radially symmetric function. In particular, in d dimensions, the radial Fourier transform and its inverse are given by","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"hatF(k) = (2pi)^d2 k ^1-d2int_0^infty dr r^d2J_d2-1(kr)F(r)","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"F(r) = (2pi)^-d2 r ^1-d2int_0^infty dk k^d2J_d2-1(kr)hatF(k)","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"in which J_d2-1(x) is the bessel function of order d2-1. In the special cases of 1 and 3 dimensions, the transform simplifies into:","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"hatF(k) = 2int_0^infty dr cos(kr)F(r)","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"F(r) = frac1piint_0^infty dk cos(kr)hatF(k)","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"in 1d, and ","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"hatF(k) = frac4pikint_0^infty dr r sin(kr)F(r)","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"F(r) = frac12pi^2rint_0^infty dk ksin(kr)hatF(k)","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"in 3d. This package uses discrete versions of all of the above. ","category":"page"},{"location":"Theory.html#Thermodynamic-properties","page":"Theory","title":"Thermodynamic properties","text":"","category":"section"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"Using the structure as determined by this package, several thermodynamic properies can be computed. In particular, this package contains methods to compute the (virial) pressure p, the isothermal compressibility chi, and the excess internal energy per particle E_x.","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"For mixtures, they are computed respectively from the following definitions","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"p =  k_BT rho_0sum_i x_i - 16 rho_0^2 sum_ij x_i x_j int dtextbfr r g_ij(r) u_ij(r)","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"1χ = 1 - ρ_0 sum_ij x_i x_j hatc_ij(kto0)","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":",","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"E_x =   12 rho_0 sum_ij x_i x_j  int dtextbfr  g_ij(r) u_ij(r)","category":"page"},{"location":"Theory.html","page":"Theory","title":"Theory","text":"in which rho_0=NV. The functions to use are compute_virial_pressure, compute_compressibility, and, compute_excess_energy.","category":"page"},{"location":"FromPython.html#Calling-from-Python","page":"From Python","title":"Calling from Python","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"Using OrnsteinZernike from Python is straighforward","category":"page"},{"location":"FromPython.html#Installing","page":"From Python","title":"Installing","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"First, install juliacall through the pip package manager, with","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"pip install juliacall","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"This package allows one to call julia from python ","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"In Python (only versions geq 3 are supported), run:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"from juliacall import Main as jl","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"which will install the latest stable version of Julia the first time it is called. Now install OrnsteinZernike.jl, with","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"jl.Pkg.add(\"OrnsteinZernike\")","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"To import this package in order to use it we need to run:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"jl.seval(\"using OrnsteinZernike\")","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"The jl.seval function let's us evaluate any julia code from within Python.","category":"page"},{"location":"FromPython.html#Usage","page":"From Python","title":"Usage","text":"","category":"section"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"We can now use OrnsteinZernike.jl in Python:","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"dims = 3\nkBT = 1.0\nrho = 0.5\npotential = jl.HardSpheres(1.0)\nsystem = jl.SimpleLiquid(dims, rho, kBT, potential)\nclosure = jl.PercusYevick()\nsol = jl.solve(system, closure)\n\nimport matplotlib.pyplot as plt\n\nplt.plot(sol.r, sol.gr)\nplt.xlim(0, 5)\nplt.show()","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"(Image: image)","category":"page"},{"location":"FromPython.html","page":"From Python","title":"From Python","text":"See the documentation of juliacall for more information on how to call Julia from Python.","category":"page"},{"location":"Potentials.html#Interaction-Potentials","page":"Interaction Potentials","title":"Interaction Potentials","text":"","category":"section"},{"location":"Potentials.html","page":"Interaction Potentials","title":"Interaction Potentials","text":"This package defines several potentials that can be used out of the box. It is straightforward to implement your own potential, see Defining your own potentials. To evaluate the potential, call OrnsteinZernike.evaluate_potential(potential, r). For example:","category":"page"},{"location":"Potentials.html","page":"Interaction Potentials","title":"Interaction Potentials","text":"using OrnsteinZernike, Plots\nr = 0.9:0.01:4.0\npotential = LennardJones(1.0, 1.0)\nu = OrnsteinZernike.evaluate_potential(potential, r)\nplot(r, u, xlabel=\"r\", ylabel=\"u(r)\", ylims=(-1,1), label=nothing)","category":"page"},{"location":"Potentials.html#Implemented-interaction-potentials","page":"Interaction Potentials","title":"Implemented interaction potentials","text":"","category":"section"},{"location":"Potentials.html","page":"Interaction Potentials","title":"Interaction Potentials","text":"Below is a list of implemented closures. We use the notation shown in the Theory section.","category":"page"},{"location":"Potentials.html","page":"Interaction Potentials","title":"Interaction Potentials","text":"Modules = [OrnsteinZernike]\nFilter = t -> (typeof(t) === DataType || typeof(t) === UnionAll) && t <: OrnsteinZernike.Potential\nPrivate = false","category":"page"},{"location":"Potentials.html#OrnsteinZernike.CustomPotential","page":"Interaction Potentials","title":"OrnsteinZernike.CustomPotential","text":"CustomPotential\n\nImplements a potential that evaluates a user defined function.\n\nExpects values f, and p, which respecively are a callable and a list of parameters. The function should be called f(r::Number, p) and it should produce either a Number, in the case of a single-component system, or an SMatrix, in the case of a multicomponent system. \n\nExample:\n\nf = (r, p) -> 4*p[1]*((p[2]/r)^12 -  (p[2]/r)^6)\npotential = CustomPotential(f, (1.0, 1.0))\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.HardSpheres","page":"Interaction Potentials","title":"OrnsteinZernike.HardSpheres","text":"HardSpheres\n\nImplements the hard-sphere pair interaction for single component systems $ u(r) = \\infty$ for r  1 and u(r) = 0 for r  1, or u_ij(r) = infty for r  D_ij and u_ij(r) = 0 for r  D_ij for mixtures.\n\nFor mixtures expects either a vector D_i of diameters for each of the species in which case an additive mixing rule is used left(D_ij = (D_i+D_j)2right)  or a matrix D_ij of pair diameters.\n\nExample:\n\npotential = HardSpheres(1.0)\n\nExample:\n\npotential = HardSpheres([0.8, 0.9, 1.0])\n\nDij = rand(3,3)\npotential = HardSpheres(Dij)\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.LennardJones","page":"Interaction Potentials","title":"OrnsteinZernike.LennardJones","text":"LennardJones\n\nImplements the Lennard-Jones pair interaction u(r) = 4epsilon (sigmar)^12 - (sigmar)^6.\n\nExpects values ϵ and σ, which respecively are the strength of the potential and particle size. \n\nExample:\n\npotential = LennardJones(1.0, 2.0)\n\n\n\n\n\n","category":"type"},{"location":"Potentials.html#OrnsteinZernike.PowerLaw","page":"Interaction Potentials","title":"OrnsteinZernike.PowerLaw","text":"PowerLaw\n\nImplements the power law pair interaction u(r) = epsilon (sigmar)^n.\n\nExpects values ϵ, σ, and n, which respecively are the strength of the potential and particle size. \n\nExample:\n\npotential = PowerLaw(1.0, 2.0, 8)\n\n\n\n\n\n","category":"type"},{"location":"GeneralWorkflow.html#General-Workflow","page":"General Workflow","title":"General Workflow","text":"","category":"section"},{"location":"GeneralWorkflow.html","page":"General Workflow","title":"General Workflow","text":"In general, solving an Ornstein-Zernike equation requires the definition of following items. The linked pages describe these in more details. ","category":"page"},{"location":"GeneralWorkflow.html","page":"General Workflow","title":"General Workflow","text":"The interaction potential: Interaction Potentials\nThe system parameters: density, temperature and dimensionality: Systems \nThe closure relation: Closures\nThe solver: Solvers","category":"page"},{"location":"GeneralWorkflow.html","page":"General Workflow","title":"General Workflow","text":"Once these have been defined, solve can be called to solve the system at hand. ","category":"page"},{"location":"Solvers.html#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"Having defined a SimpleLiquid and a Closure, one may choose a method by which to solve the equations. The implemented methods are Exact, FourierIteration, NgIteration. If no method is given the solve function, it will use the default NgIteration.","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"All solvers in some way, need to define a grid on which to solve the equations. This is done using the keyword arguments for M and dr, which represent respectively the number of grid points, and the spacing between them. Some solvers have additional settings, such as a tolerance. Using powers of 2 for M typically give the best performance (for 3D systems). For N dimensional systems, the grid is constructed such that all M points lie below M*dr, but dr may not be the exact grid spacing between all points.","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"For the implemented cases, Exact solves the system exactly, or throws an error if the method is not implemented. ","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"Exact","category":"page"},{"location":"Solvers.html#OrnsteinZernike.Exact","page":"Solvers","title":"OrnsteinZernike.Exact","text":"Exact <: Method\n\nSolves the system exactly. This is only implemented for specific systems.\n\nRight now, the implemented exact methods are\n\nthree-dimensional single-component system of hard spheres with the Percus Yevick closure [1]\nthree-dimensional multi-component system of additive hard spheres with the Percus Yevick closure [2]\none-dimensional single-component system of hard spheres with the Percus Yevick closure [3]\nfive-dimensional single-component system of hard spheres with the Percus Yevick closure [3]\n\nConstruct using \n\nExact(;  M=2^10, dr = sqrt(π/(M+1))/(2π))\n\nHere, M is the number of points that the exact solution is evaluated on, and dr is the grid spacing. These are used to perform Fourier transformations.\n\nExamples\n\nmethod = Exact()\n\nmethod = Exact(M=1000)\n\nmethod = Exact(M=1000, dr=0.01)\n\nReferences:\n\nWertheim, M. S. \"Exact solution of the Percus-Yevick integral equation for hard spheres.\" Physical Review Letters 10.8 (1963): 321.\nBaxter, R. J. \"Ornstein–Zernike relation and Percus–Yevick approximation for fluid mixtures.\" The Journal of Chemical Physics 52.9 (1970): 4559-4562.\nLeutheusser, E. \"Exact solution of the Percus-Yevick equation for a hard-core fluid in odd dimensions.\" Physica A: Statistical Mechanics and its Applications 127.3 (1984): 667-676.\n\n\n\n\n\n","category":"type"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"The methods FourierIteration and NgIteration both use recursive iteration to find improved estimates of the solution using Fourier Transforms. NgIteration uses a scheme to accelerate convergence, see Ref. [1]. ","category":"page"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"FourierIteration\nNgIteration","category":"page"},{"location":"Solvers.html#OrnsteinZernike.FourierIteration","page":"Solvers","title":"OrnsteinZernike.FourierIteration","text":"FourierIteration <: Method\n\nSolves the system by recursive iteration in Fourier Space. Essentially, the algorithm is:\n\nguess an initial γ(r)\nfind c(r) using the closure relation\nfourier transform to get ĉ(k)\nfind γ(k) using the OZ-eq in k-space\ncompute γ(r) with a inverse fourier transform\ncompare with previous value, if not converged go to 2.\n\nOptionally, a mixing rule is used to mix the new and previous iteration of c(r) in step 2. \n\nArguments:\n\nM::Int: number of points discretize the solution on \ndr::Float64: grid spacing in real space\nmixing_parameter::Float64: mixing parameter for iteration mixing. A value of 1 is no mixing. Must be between 0 and 1. \nmax_iterations::Int64: maximal number of iterations \ntolerance::Float64: tolerance to be reached\nverbose::Bool: whether or not to print convergence information\n\nDefault: FourierIteration(; mixing_parameter=0.5, max_iterations=10^5, tolerance=10^-6, verbose=true, M=2^10, dr=sqrt(π/(M+1))/(2π))\n\n\n\n\n\n","category":"type"},{"location":"Solvers.html#OrnsteinZernike.NgIteration","page":"Solvers","title":"OrnsteinZernike.NgIteration","text":"NgIteration <: Method\n\nSolves the system by recursive iteration in Fourier Space, and uses the Ng acceleration method. Essentially, the algorithm is:\n\nguess an initial γ(r)\nfind c(r) using the closure relation\nfourier transform to get ĉ(k)\nfind γ(k) using the OZ-eq in k-space\ncompute γ(r) with a inverse fourier transform\nuse Ng's method to provide a next guess for γ\ncompare with previous value, if not converged go to 2.\n\nArguments:\n\nM::Int: number of points discretize the solution on \ndr::Float64: grid spacing in real space\nN_stages::Int: Number of previous values to take into account for step 6. A higher number should lead to faster convergence, yet more computation time per iteration.\nmax_iterations::Int64: maximal number of iterations \ntolerance::Float64: tolerance to be reached\nverbose::Bool: whether or not to print convergence information\n\nDefault: NgIteration(; N_stages=3, max_iterations=10^3, tolerance=10^-6, verbose=true, M=2^10, dr=sqrt(π/(M+1))/(2π))\n\nReferences: Ng, K. C. (1974). Hypernetted chain solutions for the classical one‐component plasma up to Γ= 7000. The Journal of Chemical Physics, 61(7), 2680-2689.\n\n\n\n\n\n","category":"type"},{"location":"Solvers.html#Meta-solvers","page":"Solvers","title":"Meta-solvers","text":"","category":"section"},{"location":"Solvers.html","page":"Solvers","title":"Solvers","text":"DensityRamp","category":"page"},{"location":"Solvers.html#OrnsteinZernike.DensityRamp","page":"Solvers","title":"OrnsteinZernike.DensityRamp","text":"DensityRamp <: Method\n\nSolves the system by iteratively solving systems of increasing density, using the previous solution as initial guess at a higher density. This may help deal with convergence issues.\n\nArguments\n\nmethod: method by which to solve the system for individual densities.\ndensities: densities to consider. Must be a vector of increasing values.\nverbose: whether to print information.\n\nExample: DensityRamp(NgIteration(), [0.1, 0.3, 0.4]; verbose=false)\n\n\n\n\n\n","category":"type"},{"location":"ExtendingPotentials.html#Defining-your-own-potentials","page":"Defining your own potentials","title":"Defining your own potentials","text":"","category":"section"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"Creating your own potentials type is very easy. We can do this by making use of the CustomPotential","category":"page"},{"location":"ExtendingPotentials.html#Example","page":"Defining your own potentials","title":"Example","text":"","category":"section"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"We want to implement the interaction potential  u(r) = epsilon left(fracsigmarright)^6","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"To do this, first we define the function. This function should take two arguments, r::Number and p, the latter of which contains optional parameters that the function uses. For example:","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"u = (r, p) ->p.ϵ*(p.σ/r)^6","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"Now we can instantiate the CustomPotential","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"using OrnsteinZernike\np = (ϵ = 1.0, σ = 1.0)\npotential = CustomPotential(u, p)","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"Now we can use the potential as any other ","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"dims = 3 # we consider a 3D system\nρ = 0.6 # number density\nkBT = 1.0 # thermal energy\nsystem = SimpleLiquid(dims, ρ, kBT, potential)\nclosure = HypernettedChain()\nsol = solve(system, closure)\nusing Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\")","category":"page"},{"location":"ExtendingPotentials.html#Mixtures","page":"Defining your own potentials","title":"Mixtures","text":"","category":"section"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"In the case of multicomponent systems, instead of a number the function should return a StaticMatrix from the StaticArrays package containing values for u_ij. ","category":"page"},{"location":"ExtendingPotentials.html#Example-2","page":"Defining your own potentials","title":"Example","text":"","category":"section"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"Suppose we want to implement the same potential for the multicomponent case: u_ij(r) = epsilon_ij (fracsigma_ijr_ij)^6","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"While one could implement this in one line with broadcasting, here the function is written out fully for clarity:","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"using OrnsteinZernike, StaticArrays \n\nfunction mypotential(r, p)\n    # we can construct a mutable sized matrix first\n    Nspecies = size(p.ϵ, 1)\n    out = MMatrix{Nspecies, Nspecies, Float64, Nspecies*Nspecies}(undef) \n    for species2 = 1:Nspecies\n        for species1 = 1:Nspecies\n            out[species1, species2] = p.ϵ[species1, species2] * (p.σ[species1, species2] / r) ^ 6\n        end\n    end\n    # and convert it to an immutable variant\n    return SMatrix(out) \nend","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"and now we can use it:","category":"page"},{"location":"ExtendingPotentials.html","page":"Defining your own potentials","title":"Defining your own potentials","text":"ϵ = SMatrix{2,2}([1.0 2.0; 0.4 0.9])\nσ = SMatrix{2,2}([1.0 1.0; 1.0 0.8])\np = (ϵ = ϵ, σ = σ)\ndims = 3 # we consider a 3D system\npotential = CustomPotential(mypotential, p)\nρ = [0.25, 0.25] # number density\nkBT = 1.0 # thermal energy\nsystem = SimpleLiquid(dims, ρ, kBT, potential)\nclosure = HypernettedChain()\nsol = solve(system, closure)\nusing Plots\nplot(sol.r, sol.gr[:, 1, 1], xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", label=\"g11(r)\")\nplot!(sol.r, sol.gr[:, 1, 2], xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", label=\"g12(r)\")\nplot!(sol.r, sol.gr[:, 2, 2], xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", label=\"g22(r)\")","category":"page"},{"location":"ThermodynamicConsistency.html#Thermodynamic-Consistency","page":"Thermodynamic Consistency","title":"Thermodynamic Consistency","text":"","category":"section"},{"location":"ThermodynamicConsistency.html","page":"Thermodynamic Consistency","title":"Thermodynamic Consistency","text":"Some Closures have free parameters that can be tuned to obtain the most accurate bridge functions. For example, the famous Rogers-Young closure RogersYoung interpolates between the Percus-Yevick closure and the Hypernetted Chain one with a free parameter alpha. While this parameter can be chosen freely, it is usually chosen such that the solutions satisfy thermodynamic consistency. ","category":"page"},{"location":"ThermodynamicConsistency.html#Free-choice-of-\\alpha","page":"Thermodynamic Consistency","title":"Free choice of alpha","text":"","category":"section"},{"location":"ThermodynamicConsistency.html","page":"Thermodynamic Consistency","title":"Thermodynamic Consistency","text":"To warm up, let's solve a 3D hard-sphere system for alpha=05","category":"page"},{"location":"ThermodynamicConsistency.html","page":"Thermodynamic Consistency","title":"Thermodynamic Consistency","text":"using OrnsteinZernike, Plots\nM = 5000\nρ = 0.6 * sqrt(2)\ndr = 20.0/M\nkBT = 1.0\ndims = 3 \nα = 0.5\npot = HardSpheres(1.0)\nsystem = SimpleLiquid(dims, ρ, kBT, pot)\nmethod = NgIteration(M=M, dr=dr, verbose=false)\nsolRY = solve(system, RogersYoung(α), method)\nsolPY = solve(system, PercusYevick(), method)\nsolHNC = solve(system, HypernettedChain(), method)\n\nplot(solRY.r, solRY.gr, label=\"Rogers-Young\")\nplot!(solPY.r, solPY.gr, label=\"Percus-Yevick\")\nplot!(solHNC.r, solHNC.gr, label=\"Hypernetted Chain\")\nplot!(xlims=(0.9,2.3), xlabel=\"r\", ylabel=\"g(r)\")","category":"page"},{"location":"ThermodynamicConsistency.html","page":"Thermodynamic Consistency","title":"Thermodynamic Consistency","text":"Here, we can see, that indeed, the Rogers-Young closure finds a middle ground between the two others. ","category":"page"},{"location":"ThermodynamicConsistency.html#Using-thermodynamics","page":"Thermodynamic Consistency","title":"Using thermodynamics","text":"","category":"section"},{"location":"ThermodynamicConsistency.html","page":"Thermodynamic Consistency","title":"Thermodynamic Consistency","text":"There are a number of thermodynamic relations that allow a consistent choice of alpha. Here we opt for frac1beta chi_T=left(fracpartial ppartial rhoright)_T. For simplicity, we use finite differences to obtain the derivative of the pressure. See the Theory section for more details. Subsequently, we use the bisection method from Roots.jl to find the optimal parameter. The results can be compared to Table 1 in Ref. 1. ","category":"page"},{"location":"ThermodynamicConsistency.html","page":"Thermodynamic Consistency","title":"Thermodynamic Consistency","text":"using OrnsteinZernike, Plots\nimport Roots\nfunction find_self_consistent_solution(ρ, kBT, M, dr, dims, pot)\n\n    function RY_inconsistency(ρ, α)\n        system1 = SimpleLiquid(dims, ρ, kBT, pot)\n        method = NgIteration(M=M, dr=dr, verbose=false)\n        sol1 = solve(system1, RogersYoung(α), method)\n        p1 = compute_virial_pressure(sol1, system1)\n\n        dρ = sqrt(eps(ρ))\n        system2 = SimpleLiquid(dims, ρ+dρ, kBT, pot)\n        sol2 = solve(system2, RogersYoung(α), method)\n        p2 = compute_virial_pressure(sol2, system2)\n        dpdρ = (p2-p1)/dρ\n\n        χ = compute_compressibility(sol1, system1)\n        inconsistency = dpdρ/kBT - 1/(ρ*kBT*χ)\n        return inconsistency\n    end\n\n    func = α ->  RY_inconsistency(ρ, α)\n    α =  Roots.find_zero(func, (0.001,50.0), Roots.Bisection(), atol=0.0001)\n    system = SimpleLiquid(dims, ρ, kBT, pot)\n    method = NgIteration(M=M, dr=dr, verbose=false)\n    sol = solve(system, RogersYoung(α), method)\n    return system, sol, α\nend\n\nfor ρstar = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.654]\n    ρ = ρstar*sqrt(2)\n    M = 1000\n    dr = 10.0/M\n    kBT = 1.0\n    dims = 3 \n    pot = HardSpheres(1.0)\n    system, sol, α = find_self_consistent_solution(ρ, kBT, M, dr, dims, pot)\n    P = compute_virial_pressure(sol, system)/ρ/kBT - 1\n    gmax = maximum(sol.gr)\n    println(\"At ρ/√2 = $(ρstar), we find α = $(round(α,digits=2)), and βp/ρ - 1 = $(round(P,digits=4)).\")\nend","category":"page"},{"location":"ThermodynamicConsistency.html","page":"Thermodynamic Consistency","title":"Thermodynamic Consistency","text":"References:","category":"page"},{"location":"ThermodynamicConsistency.html","page":"Thermodynamic Consistency","title":"Thermodynamic Consistency","text":"Rogers, Forrest J., and David A. Young. \"New, thermodynamically consistent, integral equation for simple fluids.\" Physical Review A 30.2 (1984): 999.","category":"page"},{"location":"Systems.html#Systems","page":"Systems","title":"Systems","text":"","category":"section"},{"location":"Systems.html","page":"Systems","title":"Systems","text":"A System object specifies what type of system needs to be solved. This includes the dimensionality, density and temperature, as well as the interaction potential as defined according to the previous page. Right now, this package exports only one type of System: SimpleLiquid. ","category":"page"},{"location":"Systems.html#SimpleLiquid","page":"Systems","title":"SimpleLiquid","text":"","category":"section"},{"location":"Systems.html","page":"Systems","title":"Systems","text":"The SimpleLiquid system assumes that the potentials involved are rotationally symmetric, and therefore depends only on center-to-center distance. Additionally, it assumes that there is no present external field. It can be used both in the single component case, as well as for multi-component systems (mixtures).","category":"page"},{"location":"Systems.html","page":"Systems","title":"Systems","text":"For single component systems, the density ρ is assumed to be a scalar, while for multicomponent systems, it should be a vector. Internally, the package converts it into a diagonal matrix.","category":"page"},{"location":"Systems.html","page":"Systems","title":"Systems","text":"Example 1: a 2-dimensional Lennard-Jones system","category":"page"},{"location":"Systems.html","page":"Systems","title":"Systems","text":"using OrnsteinZernike \npotential = LennardJones(1.0, 1.0)\nkBT = 1.0\nρ = 0.5\ndims = 2\nsystem = SimpleLiquid(dims, ρ, kBT, potential)","category":"page"},{"location":"Systems.html","page":"Systems","title":"Systems","text":"Example 1: a 3-dimensional 10-component hard-sphere system","category":"page"},{"location":"Systems.html","page":"Systems","title":"Systems","text":"using OrnsteinZernike # hide \nD = 0.1:0.1:1.0\npotential = HardSpheres(D)\nkBT = 1.0\nρ = ones(10)/10\ndims = 3\nsystem = SimpleLiquid(dims, ρ, kBT, potential)","category":"page"},{"location":"Closures.html#Closures","page":"Closures","title":"Closures","text":"","category":"section"},{"location":"Closures.html","page":"Closures","title":"Closures","text":"This package defines several closure relations that can be used out of the box. It is straightforward to implement your own closure, see Defining your own closure. ","category":"page"},{"location":"Closures.html","page":"Closures","title":"Closures","text":"Some closures, for example the Rogers-Young closure, include free parameters that may be fixed by the requirement of thermodynamic consistency. See the Thermodynamic Consistency page for an example. ","category":"page"},{"location":"Closures.html","page":"Closures","title":"Closures","text":"Some closures use a renormalized indirect correlation function gamma^*(r) = gamma(r) - u_LR(r) instead of the standard one. Here, u_LR(r) is the long range tail of the interaction potential. There are several ways in which the interaction potential can be split into a short-range and long range part, the most common one is the Weeks-Chandler-Andersen construction. In order to use these ... ","category":"page"},{"location":"Closures.html#Implemented-Closures","page":"Closures","title":"Implemented Closures","text":"","category":"section"},{"location":"Closures.html","page":"Closures","title":"Closures","text":"Below is an alphabetical list of implemented closures. We use the notation shown in the Theory section.","category":"page"},{"location":"Closures.html","page":"Closures","title":"Closures","text":"Modules = [OrnsteinZernike]\nPages = [\"Closures.md\"]\nOrder   = [:type]\nPrivate = false","category":"page"},{"location":"Closures.html","page":"Closures","title":"Closures","text":"Modules = [OrnsteinZernike]\nFilter = t -> ((typeof(t) === DataType || typeof(t) === UnionAll) && t <: OrnsteinZernike.Closure)\nPrivate = false","category":"page"},{"location":"Closures.html#OrnsteinZernike.BallonePastoreGalliGazzillo","page":"Closures","title":"OrnsteinZernike.BallonePastoreGalliGazzillo","text":"BallonePastoreGalliGazzillo <: Closure\n\nImplements the Ballone-Pastore-Galli-Gazzillo closure b(r) = (1 + s gamma(r))^1s - gamma(r) - 1  Here s is a free parameter that can be determined with thermodynamic consistency.\n\nExample:\n\nclosure = BallonePastoreGalliGazzillo(1.5)\n\nReferences:\n\nBallone, P., et al. \"Additive and non-additive hard sphere mixtures: Monte Carlo simulation and integral equation results.\" Molecular Physics 59.2 (1986): 275-290.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.BomontBretonnet","page":"Closures","title":"OrnsteinZernike.BomontBretonnet","text":"BomontBretonnet <: Closure\n\nImplements the Bomont-Bretonnet closure b(r) = sqrt1+2gamma^*(r) + f gamma^*(r)^2 - gamma^*(r) - 1   Here  gamma^* = gamma - u_LR , in which $ u_{LR}$ is the long range tail of the potential, and f is a free parameter that can be determined with thermodynamic consistency.\n\nExample:\n\nclosure = BomontBretonnet(0.5)\n\nReferences:\n\nBomont, J. M., and J. L. Bretonnet. \"A self-consistent integral equation: Bridge function and thermodynamic properties for the Lennard-Jones fluid.\" The Journal of chemical physics 119.4 (2003): 2188-2191.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.CharpentierJackse","page":"Closures","title":"OrnsteinZernike.CharpentierJackse","text":"CharpentierJackse <: Closure\n\nImplements the Charpentier-Jackse closure b(r) = frac12alphaleft(sqrt1+4alphagamma^*(r)  - 2alphagamma^*(r) - 1right)  Here  gamma^* = gamma - u_LR , in which $ u_{LR}$ is the long range tail of the potential, and alpha is a free parameter that  can be determined with thermodynamic consistency.\n\nExample:\n\nclosure = CharpentierJackse(0.5)\n\nReferences:\n\nCharpentier, I., and N. Jakse. \"Exact numerical derivatives of the pair-correlation function of simple liquids using the tangent linear method.\" The Journal of Chemical Physics 114.5 (2001): 2284-2292.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.ChoudhuryGhosh","page":"Closures","title":"OrnsteinZernike.ChoudhuryGhosh","text":"ChoudhuryGhosh <: Closure\n\nImplements the Choudhury-Ghosh closure b(r) = -frac-gamma^*(r)^22(1+alpha gamma^*(r))  for gamma^*(r) 0, and b(r)=-gamma^*(r)^22 otherwise. Here  gamma^* = gamma - u_LR , in which $ u_{LR}$ is the long range tail of the potential, and alpha is a free parameter that  is determined by an empirical relation.\n\nExample:\n\nα(ρ) = 1.01752 - 0.275ρ # see the reference for this empirical relation\nclosure = ChoudhuryGhosh(α(0.4))\n\nReferences:\n\nChoudhury, Niharendu, and Swapan K. Ghosh. \"Integral equation theory of Lennard-Jones fluids: A modified Verlet bridge function approach.\" The Journal of chemical physics 116.19 (2002): 8517-8522.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.DuhHaymet","page":"Closures","title":"OrnsteinZernike.DuhHaymet","text":"DuhHaymet <: Closure\n\nImplements the Duh-Haymet closure b(r) = frac-gamma^*(r)^22left1+left(frac5gamma^*(r)+117gamma^*(r)+9right)gamma^*(r)right  for gamma^*(r) 0, and b(r)=-gamma^*(r)^22 otherwise. Here  gamma^* = gamma - u_LR , in which $ u_{LR}$ is the long range tail of the potential, \n\nExample:\n\nclosure = DuhHaymet()\n\nReferences:\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.HypernettedChain","page":"Closures","title":"OrnsteinZernike.HypernettedChain","text":"HypernettedChain\n\nImplements the Hypernetted Chain closure c(r) = (f(r)+1)exp(gamma(r)) - gamma(r) - 1, or equivalently b(r) = 0.\n\nExample:\n\nclosure = HypernettedChain()\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.Khanpour","page":"Closures","title":"OrnsteinZernike.Khanpour","text":"Khanpour <: Closure\n\nImplements the Khanpour closure b(r) = frac1alphaln(1+alphagamma(r)) - gamma   Here alpha is a free parameter that can be determined with thermodynamic consistency.\n\nExample:\n\nclosure = Khanpour(0.5)\n\nReferences:\n\nKhanpour, Mehrdad. \"A unified derivation of Percus–Yevick and hyper-netted chain integral equations in liquid state theory.\" Molecular Physics 120.5 (2022): e2001065.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.Lee","page":"Closures","title":"OrnsteinZernike.Lee","text":"Lee <: Closure\n\nImplements the Lee closure b(r) = -fraczetagamma^*(r)^22 left( 1- fracphi alpha gamma^*(r)1 + alphagamma^*(r) right)  Here  gamma^* = gamma + ρ f(r)2 , in which $ f(r)$ is the Mayer-f function and rho the density. Additionally, zeta,phi, and, alpha are free parameters that  can be determined with thermodynamic consistency or zero-separation theorems.\n\nExample:\n\nclosure = Lee(1.073, 1.816, 1.0, 0.4) # ζ, ϕ, α, ρ\n\nReferences:\n\nLee, Lloyd L. \"An accurate integral equation theory for hard spheres: Role of the zero‐separation theorems in the closure relation.\" The Journal of chemical physics 103.21 (1995): 9388-9396.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.MartynovSarkisov","page":"Closures","title":"OrnsteinZernike.MartynovSarkisov","text":"MartynovSarkisov <: Closure\n\nImplements the Martynov-Sarkisov Closure b(r) = -\\sqrt{1+2\\gamma}-1-\\gamma, which is constructed for the 3d hard-sphere liquid.\n\nExample:\n\nclosure = MartynovSarkisov()\n\nReferences:\n\nMartynov, G. A., and G. N. Sarkisov. \"Exact equations and the theory of liquids. V.\" Molecular Physics 49.6 (1983): 1495-1504.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.MeanSpherical","page":"Closures","title":"OrnsteinZernike.MeanSpherical","text":"MeanSpherical\n\nImplements the MSA closure c(r) = -beta u(r), or equivalently b(r) = ln(gamma(r) - beta u(r) + 1) - γ(r) +  beta u(r).\n\nExample:\n\nclosure = MeanSpherical()\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.PercusYevick","page":"Closures","title":"OrnsteinZernike.PercusYevick","text":"PercusYevick\n\nImplements the Percus-Yevick closure c(r) = f(r)(1+gamma(r)), or equivalently b(r) = ln(1 + gamma(r)) - γ(r).\n\nExample:\n\nclosure = PercusYevick()\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.ReferenceHypernettedChain","page":"Closures","title":"OrnsteinZernike.ReferenceHypernettedChain","text":"ReferenceHypernettedChain <: Closure\n\nImplements the Reference Hypernetted Chain closure b(r) = b_HS(r)  Here b_HS(r)=left((a_1+a_2x)(x-a_3)(x-a_4)(a_3 a_4)right)^2 for xa_4 and b_HS(r)=left(A_1 exp(-a_5(x-a_4))sin(A2(x-a_4))rright)^2 is the hard sphere bridge function found in Malijevský & Labík. The parameters are defined as\n\nx = r-1\n\nA_1 = (a_1+a_2 a_4)(a_4-a_3)(a_4+1)(A_2 a_3 a_4)\n\nA_2 =  pi  (a_6 - a_4 - 1)\n\na_1 = eta (155707 - 185633eta)  (1-eta)^2\n\na_2 = eta (128127 - 182134eta)  (1-eta)\n\na_3 =  (074480 - 093453eta)\n\na_4 = (117102 - 068230eta)\n\na_5 = 015975eta^2\n\na_6 = (269757 - 086987eta)\n\nand eta is the volume fraction of the hard sphere reference system. This closure only works for single component systems in three dimensions.\n\nExample:\n\nclosure = ReferenceHypernettedChain(0.4)\n\nReferences:\n\nLado, F. \"Perturbation correction for the free energy and structure of simple fluids.\" Physical Review A 8.5 (1973): 2548.\n\nMalijevský, Anatol, and Stanislav Labík. \"The bridge function for hard spheres.\" Molecular Physics 60.3 (1987): 663-669.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.RogersYoung","page":"Closures","title":"OrnsteinZernike.RogersYoung","text":"RogersYoung <: Closure\n\nImplements the Rogers-Young closure b(r) = ln(fracexp(f(r)gamma(r)) - 1f(r) + 1) - γ(r)   Here f(r)=1-exp(-alpha r), in which alpha is a free parameter,  that may be chosen such that thermodynamic consistency is achieved. Example:\n\nclosure = RogersYoung(0.5)\n\nReferences:\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.SoftCoreMeanSpherical","page":"Closures","title":"OrnsteinZernike.SoftCoreMeanSpherical","text":"SoftCoreMeanSpherical <: Closure\n\nImplements the soft core mean spherical closure b(r) = ln(gamma^*(r) + 1) - gamma^*(r). Here gamma^* = gamma - u_LR , in which u_LR is the long range tail of the potential.\n\nExample:\n\nclosure = SoftCoreMeanSpherical()\n\nReferences:\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.Verlet","page":"Closures","title":"OrnsteinZernike.Verlet","text":"Verlet <: Closure\n\nImplements the Verlet Closure b(r) = -fracAgamma^2(r)21+B gamma(r)2 where by default A=1 and B=85. These values are tuned by the virial coefficients of the 3d hard sphere liquid.\n\nExample:\n\nclosure = Verlet()\nclosure = Verlet(A=3.0, B=4.0)\n\nReferences:\n\nVerlet, Loup. \"Integral equations for classical fluids: I. The hard sphere case.\" Molecular Physics 41.1 (1980): 183-190.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.VompeMartynov","page":"Closures","title":"OrnsteinZernike.VompeMartynov","text":"VompeMartynov <: Closure\n\nImplements the Vompe-Martynov closure b(r) = sqrt1+2gamma^*(r)  - gamma^*(r) - 1  Here  gamma^* = gamma - u_LR , in which $ u_{LR}$ is the long range tail of the potential, and alpha is a free parameter that can be determined with thermodynamic consistency.\n\nExample:\n\nclosure = VompeMartynov()\n\nReferences:\n\nVompe, A. G., and G. A. Martynov. \"The bridge function expansion and the self‐consistency problem of the Ornstein–Zernike equation solution.\" The Journal of chemical physics 100.7 (1994): 5249-5258.\n\n\n\n\n\n","category":"type"},{"location":"Closures.html#OrnsteinZernike.ZerahHansen","page":"Closures","title":"OrnsteinZernike.ZerahHansen","text":"ZerahHansen <: Closure\n\nImplements the Zerah-Hansen (HMSA) (HNC-SMSA) closure b(r) = ln(fracexp(f(r)gamma^*(r)) - 1f(r) + 1) - γ^*(r)  Here  gamma^* = gamma - u_LR , in which $ u_{LR}$ is the long range tail of the potential,  and f(r)=1-exp(-alpha r), in which alpha is a free parameter,  that may be chosen such that thermodynamic consistency is achieved.\n\nExample:\n\nclosure = ZerahHansen(0.5)\n\nReferences:\n\nZerah, Gilles, and Jean‐Pierre Hansen. \"Self‐consistent integral equations for fluid pair distribution functions: Another attempt.\" The Journal of chemical physics 84.4 (1986): 2336-2343.\n\n\n\n\n\n","category":"type"},{"location":"SingleCompLJ.html#First-steps","page":"First steps","title":"First steps","text":"","category":"section"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"In order to solve an Ornstein-Zernike equation, there are a number of things that need to be specified. ","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"The interaction potential, \nThe system parameters: density, temperature and dimensionality\nThe closure relation\nThe solver","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"Let's start with a very simple example: a three-dimensional 1-component system, where the particles interact according to a power law potential. In this case, we can make use of the built-in potential ","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"using OrnsteinZernike\nϵ = 1.0\nσ = 1.0\nn = 8\npotential = PowerLaw(ϵ, σ, n)","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"Now that we have the potential, we define the system","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"dims = 3 # we consider a 3D system\nρ = 0.6 # number density\nkBT = 1.0 # thermal energy\nsystem = SimpleLiquid(dims, ρ, kBT, potential)","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"The SimpleLiquid object is meant to be used when dealing with systems that have spherically symmetric interaction potentials and no external fields. ","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"The third step is to define a closure relation. For now, let's stick to the simple Percus-Yevick closure","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"closure = HypernettedChain()","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"We can now solve the system. ","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"sol = solve(system, closure)","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"Note that we have not specified the method by which we do so. In this case, a simple default method is chosen that works well in most cases.","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"The sol object contains fields for the radial distribution function gr, direct correlation function (in real and Fourier space) cr and ck, the static structure factor Sk, and arrays for r and k. For example, we can plot the radial distribution function as follows:","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"using Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\")","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"Full code:","category":"page"},{"location":"SingleCompLJ.html","page":"First steps","title":"First steps","text":"using OrnsteinZernike\nϵ = 1.0\nσ = 1.0\nn = 8\npotential = PowerLaw(ϵ, σ, n)\ndims = 3 # we consider a 3D system\nρ = 0.6 # number density\nkBT = 1.0 # thermal energy\nsystem = SimpleLiquid(dims, ρ, kBT, potential)\nclosure = HypernettedChain()\nsol = solve(system, closure)\nusing Plots\nplot(sol.r, sol.gr, xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\")","category":"page"},{"location":"API.html#The-OrnsteinZernike-Module","page":"API","title":"The OrnsteinZernike Module","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"OrnsteinZernike","category":"page"},{"location":"API.html#OrnsteinZernike","page":"API","title":"OrnsteinZernike","text":"A generic solver package for Ornstein-Zernike equations from liquid state theory\n\n\n\n\n\n","category":"module"},{"location":"API.html#Module-Index","page":"API","title":"Module Index","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [OrnsteinZernike]\nOrder   = [:constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"API.html#Detailed-API","page":"API","title":"Detailed API","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [OrnsteinZernike]\nOrder   = [:constant, :type, :function, :macro]\nFilter = t -> (!(typeof(t) === DataType || typeof(t) === UnionAll) || (!(t <: OrnsteinZernike.Closure) && !(t <: OrnsteinZernike.Potential) && !(t <: OrnsteinZernike.Method)))\nPrivate = false","category":"page"},{"location":"API.html#OrnsteinZernike.OZSolution","page":"API","title":"OrnsteinZernike.OZSolution","text":"OZSolution\n\nHolds the solution of an Ornstein Zernike problem. \n\nFields:\n\nr: vector of distances\nk: vector of wave numbers\ngr: radial distribution function    \nSk: static structure factor\nck: direct correlation function in k space\ncr: direct correlation function in real space\n\nif the system was a single-component system, gr, Sk, ck and cr are vectors.  If instead the system was a multicomponent one, they are three dimensional vectors,  where the first dimension contains the values along r, and the second and third dimension contain the data for the species.\n\n\n\n\n\n","category":"type"},{"location":"API.html#OrnsteinZernike.SimpleLiquid","page":"API","title":"OrnsteinZernike.SimpleLiquid","text":"SimpleLiquid{dims, ...} <: System\n\nHolds information about a homogeneous, isotropic system with radially symmetric pair interactions. dims is the dimensionality.\n\nConstruct using\n\nSimpleLiquid(dims, ρ, kBT, potential)\n\nFields:\n\nρ: number density, must be either a Number in case of a single component system, or a Vector in case of a mixture. In the latter case, each element contains the number density of the respective component.\nkBT: thermal energy\npotential::Potential: the interaction potential.  \n\nExamples:\n\nρ = 0.5; kBT = 1.1; dims = 3\npot = SingleComponentHardSpheres()\nsystem = SimpleLiquid(dims, ρ, kBT, pot)\n\nρ = [0.5, 0.1]; kBT = 5.2; dims = 3\npot = MultiComponentHardSpheres([1.0, 0.8])\nsystem = SimpleLiquid(dims, ρ, kBT, pot)\n\n\n\n\n\n","category":"type"},{"location":"API.html#OrnsteinZernike.compute_compressibility-Union{Tuple{P}, Tuple{T2}, Tuple{T1}, Tuple{species}, Tuple{dims}, Tuple{OZSolution, SimpleLiquid{dims, species, T1, T2, P}}} where {dims, species, T1, T2, P}","page":"API","title":"OrnsteinZernike.compute_compressibility","text":"compute_compressibility(sol::OZSolution, system::SimpleLiquid)\n\nComputes the isothermal compressibility χ of the system\n\nuses the formula 1/χ = 1 - ρ ĉ(k=0) for single component systems and 1/χ = 1 - ρ Σᵢⱼ xᵢxⱼ ĉᵢⱼ(k=0) for mixtures. \n\n\n\n\n\n","category":"method"},{"location":"API.html#OrnsteinZernike.compute_excess_energy-Union{Tuple{P}, Tuple{T2}, Tuple{T1}, Tuple{species}, Tuple{dims}, Tuple{OZSolution, SimpleLiquid{dims, species, T1, T2, P}}} where {dims, species, T1, T2, P}","page":"API","title":"OrnsteinZernike.compute_excess_energy","text":"compute_excess_energy(sol::OZSolution, system::SimpleLiquid)\n\nComputes the excess energy per particle Eₓ, such that E = (dims/2kBT + Eₓ)N.\n\nuses the formula Eₓ = 1/2 ρ ∫dr g(r) u(r) for single component systems and Eₓ = 1/2 ρ Σᵢⱼ xᵢxⱼ ∫dr gᵢⱼ(r) uᵢⱼ(r) for mixtures. Here x is the concentration fraction xᵢ=ρᵢ/sum(ρ).\n\n\n\n\n\n","category":"method"},{"location":"API.html#OrnsteinZernike.compute_virial_pressure-Union{Tuple{P}, Tuple{T2}, Tuple{T1}, Tuple{Nspecies}, Tuple{dims}, Tuple{OZSolution, SimpleLiquid{dims, Nspecies, T1, T2, P}}} where {dims, Nspecies, T1, T2, P}","page":"API","title":"OrnsteinZernike.compute_virial_pressure","text":"compute_virial_pressure(sol::OZSolution, system::SimpleLiquid)\n\nComputes the pressure via the virial route\n\nuses the formula p = kBTρ - 1/6 ρ^2 ∫dr r g(r) u'(r) for single component systems and p =  kBT Σᵢρᵢ - 1/6 Σᵢⱼ ρᵢρⱼ ∫dr r gᵢⱼ(r) u'ᵢⱼ(r) for mixtures.\n\nIt handles discontinuities in the interaction potential analytically if discontinuities(potential) is defined. For additional speed/accuracy define a method of evaluate_potential_derivative(potential, r::Number) that analytically computes du/dr.  By default this is done using finite differences.\n\n\n\n\n\n","category":"method"},{"location":"API.html#OrnsteinZernike.solve","page":"API","title":"OrnsteinZernike.solve","text":"solve(system::SimpleLiquid, closure::Closure, method::Method)\n\nSolves the system system using the closure closure with method method.\n\nsolve(system::SimpleLiquid, closure::Closure)\n\nSolves the system system using the closure closure with the default method NgIteration().\n\n\n\n\n\n","category":"function"},{"location":"HardSphereMixture.html#Hard-sphere-mixture","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"","category":"section"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"The previous example showed the case of a 1-component system. Let's instead look at mixtures here. Consider a 3:1 mixture of hard spheres with sizes 0.5 and 1.0. We solve the system with the same three steps as before.","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"First, we define the potential. Here, we must use HardSpheres, which takes a vector containing the diameters of each species.","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"using OrnsteinZernike\nD = [0.5, 1.0]\npotential = HardSpheres(D)","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"Secondly, we define the system. In this example, the total number density is rho = 16. For mixtures, the system expects a vector of individual densities. Those are computed by multiplying the total density with the concentration fraction vector.","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"ρ_total = 1.6\nρ = ρ_total*[0.75, 0.25] ## it is a 3:1 system\ndims = 3 # we consider a 3D system\nkBT = 1.0 # thermal energy\nsystem = SimpleLiquid(dims, ρ, kBT, potential)","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"Thirdly, we define the closure","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"closure = PercusYevick()","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"And now we solve the system. ","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"sol = solve(system, closure)","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"For mixtures, the fields sol.gr, sol.cr, sol.ck, and sol.Sk are now three dimensional arrays with shape (Nr, Ns, Ns). For example, g_12(r_6) is stored in sol.gr[6,1,2].","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"We just solved the system using the default iterative solver NgIteration introduced by Ng. However, in this specific case, an exact solution is implemented. To use this, we specify the method Exact().","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"method = Exact()\nsol_exact = solve(system, closure, method)","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"Let's plot the resulting g(r). ","category":"page"},{"location":"HardSphereMixture.html","page":"Hard-sphere mixture","title":"Hard-sphere mixture","text":"using Plots\np = plot(sol.r, sol.gr[:, 1, 1], xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\", lw=4, label=\"g11(r) iterative\")\nplot!(sol.r, sol.gr[:, 1, 2], xlabel=\"r\", ylabel=\"g(r)\", lw=4, label=\"g12(r) iterative\")\nplot!(sol.r, sol.gr[:, 2, 2], xlabel=\"r\", ylabel=\"g(r)\", lw=4, label=\"g22(r) iterative\")\nplot!(sol_exact.r, sol_exact.gr[:, 1, 1], lw=2, c=:black, label=\"exact\")\nplot!(sol_exact.r, sol_exact.gr[:, 1, 2], lw=2, c=:black, label=nothing)\nplot!(sol_exact.r, sol_exact.gr[:, 2, 2], lw=2, c=:black, label=nothing)\np","category":"page"},{"location":"OtherDimensions.html#Other-dimensions","page":"Other dimensions","title":"Other dimensions","text":"","category":"section"},{"location":"OtherDimensions.html","page":"Other dimensions","title":"Other dimensions","text":"The solver is written for arbitrary dimension. This means that it is straightforward to solve  for other-than-three-dimensional systems. Let's for example solve the equations for hard (hyper)spheres in different dimensions, and see what the results look like","category":"page"},{"location":"OtherDimensions.html","page":"Other dimensions","title":"Other dimensions","text":"using OrnsteinZernike, Plots\ndensities = [0.8, 0.8, 0.8, 0.8, 0.8, 0.8]\ndimensionalities = Any[5, 4, 3, 2.21, 2, 1]\np = plot(xlims=(0,5), xlabel=\"r\", ylabel=\"g(r)\")\nfor i = 1:6\n    density  = densities[i]\n    dimension = dimensionalities[i]\n    potential = HardSpheres(1.0)\n    kBT = 1.0\n    system = SimpleLiquid(dimension, density, kBT, potential)\n    closure = PercusYevick()\n    method = DensityRamp(NgIteration(), range(0.001, density-0.1, length=10))\n    sol = solve(system, closure, method)\n    plot!(p, sol.r, sol.gr .+ i, label=\"d = $dimension\")\nend\np","category":"page"},{"location":"OtherDimensions.html","page":"Other dimensions","title":"Other dimensions","text":"(Image: image)","category":"page"},{"location":"OtherDimensions.html","page":"Other dimensions","title":"Other dimensions","text":"Currently, however, noninteger dimensions below 2.0 are not supported.","category":"page"},{"location":"index.html#OrnsteinZernike.jl","page":"Index","title":"OrnsteinZernike.jl","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"OrnsteinZernike.jl provides generic solvers for Ornstein-Zernike equations from liquid state theory.","category":"page"},{"location":"index.html#Installation","page":"Index","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"To install the package run ","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"import Pkg\nPkg.add(\"OrnsteinZernike\")","category":"page"}]
}
